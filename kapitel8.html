<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; Index Tracking – Grundlagen des quantitativen Portfoliomanagements mit Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./projekt.html" rel="next">
<link href="./kapitel7.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e0fdce12ac1367d4b47c179a2935dd10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-74c88ba48ad0bebf983f0ffd06dd1671.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-e0fdce12ac1367d4b47c179a2935dd10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./kapitel8.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Index Tracking</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Grundlagen des quantitativen Portfoliomanagements mit Python</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Willkommen zu „Grundlagen des quantitativen Portfoliomanagements mit Python“</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Grundlagen der klassischen (absoluten) Portfoliooptimierung</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Relative Portfoliooptimierung</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Schätzrisiken in der Portfoliotheorie</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Verbesserte Schätzung der Inputparameter: Geschrumpfte Schätzer</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Das Black-Litterman Modell</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Berücksichtigung des Schätzrisikos: Portfolio-Resampling</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel8.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Index Tracking</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./projekt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Abschlußprojekt</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation"><span class="header-section-number">9.1</span> Motivation</a></li>
  <li><a href="#konstruktion-von-tracking-portfolios" id="toc-konstruktion-von-tracking-portfolios" class="nav-link" data-scroll-target="#konstruktion-von-tracking-portfolios"><span class="header-section-number">9.2</span> Konstruktion von Tracking Portfolios</a>
  <ul class="collapse">
  <li><a href="#überblick" id="toc-überblick" class="nav-link" data-scroll-target="#überblick"><span class="header-section-number">9.2.1</span> Überblick</a></li>
  <li><a href="#verfahren-der-quadratischen-optimierung" id="toc-verfahren-der-quadratischen-optimierung" class="nav-link" data-scroll-target="#verfahren-der-quadratischen-optimierung"><span class="header-section-number">9.2.2</span> Verfahren der quadratischen Optimierung</a></li>
  <li><a href="#regression-unter-nebenbedingungen" id="toc-regression-unter-nebenbedingungen" class="nav-link" data-scroll-target="#regression-unter-nebenbedingungen"><span class="header-section-number">9.2.3</span> Regression unter Nebenbedingungen</a></li>
  <li><a href="#lineare-optimierung" id="toc-lineare-optimierung" class="nav-link" data-scroll-target="#lineare-optimierung"><span class="header-section-number">9.2.4</span> Lineare Optimierung</a></li>
  <li><a href="#schätzproblematik-der-optimierungsparameter" id="toc-schätzproblematik-der-optimierungsparameter" class="nav-link" data-scroll-target="#schätzproblematik-der-optimierungsparameter"><span class="header-section-number">9.2.5</span> Schätzproblematik der Optimierungsparameter</a></li>
  </ul></li>
  <li><a href="#beginn-der-fallstudie" id="toc-beginn-der-fallstudie" class="nav-link" data-scroll-target="#beginn-der-fallstudie"><span class="header-section-number">9.3</span> Beginn der Fallstudie</a>
  <ul class="collapse">
  <li><a href="#laden-und-beschreiben-der-datenbasis" id="toc-laden-und-beschreiben-der-datenbasis" class="nav-link" data-scroll-target="#laden-und-beschreiben-der-datenbasis"><span class="header-section-number">9.3.1</span> Laden und Beschreiben der Datenbasis</a></li>
  <li><a href="#relative-optimierung-und-index-tracking-1" id="toc-relative-optimierung-und-index-tracking-1" class="nav-link" data-scroll-target="#relative-optimierung-und-index-tracking-1"><span class="header-section-number">9.3.2</span> Relative Optimierung und Index Tracking</a></li>
  <li><a href="#index-tracking-nach-markowitz-1987-1" id="toc-index-tracking-nach-markowitz-1987-1" class="nav-link" data-scroll-target="#index-tracking-nach-markowitz-1987-1"><span class="header-section-number">9.3.3</span> Index Tracking nach Markowitz (1987)</a></li>
  <li><a href="#regression-unter-nebenbedingungen-1" id="toc-regression-unter-nebenbedingungen-1" class="nav-link" data-scroll-target="#regression-unter-nebenbedingungen-1"><span class="header-section-number">9.3.4</span> Regression unter Nebenbedingungen</a></li>
  <li><a href="#lineare-optimierung-1" id="toc-lineare-optimierung-1" class="nav-link" data-scroll-target="#lineare-optimierung-1"><span class="header-section-number">9.3.5</span> Lineare Optimierung</a></li>
  <li><a href="#vergleich-der-ansätze" id="toc-vergleich-der-ansätze" class="nav-link" data-scroll-target="#vergleich-der-ansätze"><span class="header-section-number">9.3.6</span> Vergleich der Ansätze</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Index Tracking</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Die folgenden Ausführungen sind angelehnt an Kapitel 4 in Poddig et al.&nbsp;(2009).</p>
<section id="motivation" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="motivation"><span class="header-section-number">9.1</span> Motivation</h2>
<p>Unter dem Begriff “Index Tracking” wird die Nachbildung eines vorgegebenen Zielportfolios (<em>Target Portfolio</em>) durch ein tatsächlich zu haltendes bzw. zu realisierendes Portfolio (<em>Tracking Portfolio</em>) verstanden. Das Target Portfolio kann dabei das Benchmarkportfolio sein, z.B. ein Marktindex für einen speziellen Wertpapiermarkt. Es ist eine geeignete Konstruktion des Tracking Portfolios gesucht, welches mit seiner Wertentwicklung möglichst exakt derjenigen des Target Portfolios gleichen soll.</p>
<p>Grundsätzlich können die Motivationen für Index Tracking in zwei Gruppen kategorisiert werden: 1) Gründe die in der Anlagephilosophie und der Einstellung der (Portfolio-) Managements liegen oder aus speziellen Handelsstrategien resultieren, und (2) solche, die eher “technischen” Charakter haben.</p>
<p>Der ersten Gruppe liegt die Unterscheidung zwischen aktivem und passivem Portfoliomanagement zugrunde. Die Portfoliokonstruktion durch Verfahren der absoluten und relativen Optimierung basiert auf der Vorstellung informationsineffizienten Kapitalmärkte und auf dem Glauben des Portfoliomanagements an die eigenen, tendenziell überlegenen Prognosefähigkeiten. Das Portfoliomanagement ist überzeugt, Prognosen über die zukünftige Marktentwicklung in einer Güte bereitstellen zu können, dass die aus deren Umsetzung resultierende systematische (<strong>risikoadjustierte</strong>) Extrarendite das aktiven Portfolios die Kosten der Informationsbeschaffung, -auswertung und des aktiven Managements übersteigt. Reichen die eigenen Prognosefähigkeiten nicht aus oder erweist sich der gesamte Prozess des aktiven Portfoliomanagements als zu kostenintensiv (relativ zu den erzielbaren Extrarenditen), so ist davon konsequenterweise Abstand zu nehmen. Folgerichtig kann es in diesem Fall nur noch darum gehen, das vorgegebene Benchmarkportfolio möglichst kostengünstig zu implementieren.</p>
<p>Zum anderen können spezielle Handelsstrategien die Replikation eines Index erfordern. Beispielsweise sei hier auf den Handel oder die Emission von Indexprodukten und -derivaten hingewiesen. Ebenso basieren bestimmte Arbitragestrategien auf Indexportfolios.</p>
<p>Die “technischen” Gründe für ein Index Tracking können sehr vielfältig sein und natürlich auch im Zusammenhang mit der bewussten Entscheidung für ein passives Management oder bei Verwendung spezieller Handelsstrategien auftreten. Diese lassen sich im Wesentlichen auf zwei zentrale Ursachen reduzieren, nämlich dass der Erwerb des Target Portfolios oder Teilen davon (1) unmöglich bzw. unzulässig oder aber (2) zu teuer ist. So kann z.B. als Target Portfolio ein sogenannter synthetischer (Kapitalmarkt-) Index vorgegeben sein, welcher ein nichtkäufliches, fiktives (Wertpapier-) Portfolio darstellt. Ein anderer Grund, warum bestimmte Assets des Target Portfolios nicht oder nicht in dem benötigten Umfang erworben werden können, besteht in rechtlichen, statutarischen oder anlagekonzeptionellen Beschränkungen.</p>
</section>
<section id="konstruktion-von-tracking-portfolios" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="konstruktion-von-tracking-portfolios"><span class="header-section-number">9.2</span> Konstruktion von Tracking Portfolios</h2>
<section id="überblick" class="level3" data-number="9.2.1">
<h3 data-number="9.2.1" class="anchored" data-anchor-id="überblick"><span class="header-section-number">9.2.1</span> Überblick</h3>
<p>Zur Nachbildung eines Target Portfolios (Benchmarkportfolio, Marktindex, etc.) existieren vielfältige Möglichkeiten. Eine unmittelbar nahe liegende Variante besteht in der effektiven Nachbildung (<em>Full Replication</em>). Dabei werden alle im nachzubildenden Target Portfolio enthaltenen Assets mit ihrer dort zugrunde gelegten Gewichtung in das Tracking Portfolio aufgenommen. Dieser Ansatz führt per Konstruktion zur exakten Replikation des Target Portfolios, ist aber aus den oben genannten Gründen (u.a. hohe Kosten) in der Praxis nur selten anwendbar. Als Folge resultiert die Notwendigkeit zu einer approximativen Nachbildung (<em>Sampling</em>). Hier weicht das Tracking Portfolio in seiner Zusammensetzung zwar (mitunter deutlich) von dem Target Portfolio ab, soll dieses aber in seiner Wertentwicklung möglichst exakt verfolgen (“tracking”). Die grundlegenden Verfahrensansätze sind dabei einerseits eher heuristischer Natur (<em>Stratifying Sampling</em>) oder basieren auf einem Optimierungsansatz (<em>Optimizing Sampling</em>). Verfahren des Stratifying Sampling werden im Folgenden aufgrund ihrer fehlenden theoretischen Fundierung nicht behandelt. Die nachfolgenden Betrachtungen sind dem Optimizing Sampling gewidmet. Es werden nacheinander Verfahren der quadratischen Optimierung, der Datenanalyse, und der linearen Optimierung vorgestellt.</p>
</section>
<section id="verfahren-der-quadratischen-optimierung" class="level3" data-number="9.2.2">
<h3 data-number="9.2.2" class="anchored" data-anchor-id="verfahren-der-quadratischen-optimierung"><span class="header-section-number">9.2.2</span> Verfahren der quadratischen Optimierung</h3>
<section id="relative-optimierung-und-index-tracking" class="level4" data-number="9.2.2.1">
<h4 data-number="9.2.2.1" class="anchored" data-anchor-id="relative-optimierung-und-index-tracking"><span class="header-section-number">9.2.2.1</span> Relative Optimierung und Index Tracking</h4>
<p>Die folgenden Darstellungen zeigen, wie sich das Verfahren der relativen Optimierung mit nur wenigen Modifiktionen “umrüsten” läßt, um die Struktur eines “optimalen” Tracking Portfolios zu bestimmen.</p>
<p>Grundsätzlich kann die Aufgabenstellung bei der Konstruktion eines Tracking Portfolios durch zwei Punkte charakterisiert werden:</p>
<ol type="1">
<li><p>Es ist ein Target Portfolio (Benchmark, Index, etc.) vorgegeben, dessen Wertentwicklung und Risiko so genau wie möglich mithilfe eines noch zu bestimmenden Tracking Portfolios verfolgt (repliziert) werden soll.</p></li>
<li><p>Aufgrund verschiedener Gründe ist das Tracking Portfolio möglicherweise aus Assets zu bilden, die nicht im Target Portfolio enthalten sind. Ebenso könnten nicht alle im Target Portfolio enthaltenen Assets für eine Aufnahme in das Tracking Portfolio zur Verfügung stehen bzw. hinsichtlich des Anteilsgewichts im Tracking Portfolio beschränkt sein. Die Anlageuniversen und Restriktionen von Target und Tracking Portfolio können also sehr unterschiedlich sein.</p></li>
</ol>
<p>Offensichtlich ähnelt diese Problemstruktur deutlich derjenigen bei der relativen Optimierung mit unterschiedlichen Anlageuniversen. Allerdings soll hier nicht das Portfolio-Alpha gegen das residuale (oder aktive) Risiko maximiert werden, denn die Zielsetzung bei der relativen Optimierung trifft nicht auf die hier verfolgte Zielsetzung zu.</p>
<p>Für die Bestimmung des Tracking Portfolios stellt sich daher die Frage, wann das Benchmarkportfolio “möglichst gut” nachgebildet ist. Intuitiv muss das Tracking Portfolio folgende Eigenschaften besitzen:</p>
<ul>
<li>Das Tracking Portfolio-Alpha (relativ zur Benchmark, dem Target Portfolio) muss gleich null sein (da das Benchmark-Alpha gleich null ist).</li>
<li>Das Tracking Portfolio-Beta muss gleich eins sein (da das Benchmark-Beta gleich eins ist).</li>
<li>Das residuale (=aktive) Risiko muss minimal sein.</li>
</ul>
<p>Die Zielfunktion für die Optimierung leitet sich von dem Gedanken ab, mit dem Tracking Portfolio so eng wie möglich die Benchmark zu verfolgen. Dies entspricht der Minimierung des aktiven Risikos <span class="math inline">\(\sigma^2_{AP}\)</span>, welches sich unter Ausschluss der Timingkomponente (d.h. <span class="math inline">\(\beta_P=1\)</span>) als residuales Risiko <span class="math inline">\(\sigma^2_{\epsilon_P}\)</span> ergibt. Die Zielfunktion lautet somit:</p>
<p><span class="math display">\[
\begin{split}
\\(1a) \quad ZF(w) = \sigma^2_{\epsilon_P} \rightarrow \min_{w}!, \\
\end{split}
\]</span></p>
<p>bzw. in Matrizenschreibweise unter Verwendung der bekannten Beziehung <span class="math inline">\((\sigma^2_{\epsilon_P}=\sigma^2_P-\beta^2_P*\sigma^2_B)\)</span>:</p>
<p><span class="math display">\[ (1b) \quad ZF(w) = w_P^T\Sigma w_P-(w_P^T\beta)^2*w_B^T\Sigma w_B \rightarrow \min_{w}! \]</span></p>
<p>Die zentralen Nebenbedingungen entsprechen denen bei der relativen Optimierung:</p>
<p><span class="math display">\[
\begin{split}
&amp; \text{(a)}\ w^{T}\iota = 1 \quad bzw. \quad \ w_A^{T}\iota = 0 \qquad \text{(Budgetrestriktion)}, \\
&amp; \text{(b)}\ w\geqq 0 \qquad \text{(Leerverkaufsverbot)}, \\
&amp; \text{(c)}\ \beta_P=1 \quad \Leftrightarrow \quad \beta_{AP}=0 \quad \text{(kein Timing)}.
\end{split}
\]</span></p>
<p>Um das Benchmarkportfolio in seinen zentralen Eigenschaften nachzubilden, muss zwingend neben einem Portfolio-Beta <span class="math inline">\(\beta_P\)</span> von eins ein Portfolio-Alpha <span class="math inline">\(\alpha_P\)</span> von null gefordert werden:</p>
<p><span class="math display">\[
\begin{split}
&amp; \text{(d)}\quad \alpha_P=0 \quad \text{(keine Selektion)}.
\end{split}
\]</span></p>
<p>Da das Tracking Portfolio aus anderen Assets als die Benchmark selbst zusammengestellt werden muss, kommt es ungewollt, aber auch unvermeidbar zu einem Selektionseffekt. Die Nebenbedingung nach Gleichung (d) erzwingt zwar, dass kein systematischer Selektionseffekt in Form eines positiven oder negativen Portfolio-Alphas auftritt (oder auftreten darf), temporäre (unsystematische) Abweichungen von Tracking Portfolio- und Benchmarkrendite sind aber unausweichlich. Diese äußern sich unter den gesetzten Nebenbedingungen im unvermeidbaren Selektionsrisiko, welches hier ebenfalls dem unausweichlichen “aktiven” Risiko entspricht. Dieses sollte aber möglichst klein sein, weshalb dasjenige Portfolio gesucht wird, welches das geringstmögliche, unvermeidbare Selektionsrisiko (=aktives Risiko) besitzt.</p>
</section>
<section id="herleitung-des-tracking-errors-te" class="level4" data-number="9.2.2.2">
<h4 data-number="9.2.2.2" class="anchored" data-anchor-id="herleitung-des-tracking-errors-te"><span class="header-section-number">9.2.2.2</span> Herleitung des Tracking Errors (TE)</h4>
<p>Soweit das Tracking Portfolio nicht exakt dem Benchmarkportfolio entspricht, kann eine Renditedifferenz (=aktive Rendite) zwischen Tracking Portfolio und Benchmarkportfolio entstehen:</p>
<p><span class="math display">\[ (2) \quad r_A=r_P-r_B \]</span></p>
<p>mit</p>
<ul>
<li><span class="math inline">\(r_{A}\)</span> : aktive Rendite</li>
<li><span class="math inline">\(r_{P}\)</span> : Rendite des Tracking Portfolios</li>
<li><span class="math inline">\(r_{B}\)</span> : Rendite des Benchmarkportfolios.</li>
</ul>
<p>Unter Annahme eines univariaten, linearen Renditegenerierungsprozesses unter Verwendung des Target Portfolios als Benchmark gilt für die Rendite des Tracking Portfolios:</p>
<p><span class="math display">\[ (3) \quad r_P=\alpha_P + \beta_P*r_B+\epsilon_P, \]</span></p>
<p>mit:</p>
<ul>
<li><span class="math inline">\(\alpha_P\)</span>: autonome Eigenrendite des Portfolios <span class="math inline">\(P\)</span>, Konstante</li>
<li><span class="math inline">\(\beta_P\)</span>: Sensitivität gegenüber dem Benchmarkportfolio <span class="math inline">\(B\)</span></li>
<li><span class="math inline">\(\epsilon_P\)</span>: unsystematische, zufällige, nicht erklärbare Restgröße (auch <em>Residualrendite</em> oder <em>residuale Rendite</em> genannt).</li>
</ul>
<p>Damit folgt für die aktive Rendite unter Verwendung der Nebenbedingungen nach Gleichung (c) und (d):</p>
<p><span class="math display">\[ (4) \quad r_A=r_P-r_B=\alpha_P + \beta_P*r_B+\epsilon_P-r_B=\alpha_P+\epsilon_P=\epsilon_P. \]</span></p>
<p>Für den Erwartungswert der aktiven Rendite folgt unter den Standardannahmen eines Renditegenerierungsprozesses:</p>
<p><span class="math display">\[ (5) \quad E(r_A)=E(\epsilon_P)=0. \]</span></p>
<p>Die Varianz (bzw. alternativ die Standardabweichung) der aktiven Rendite wird beim Index Tracking als sogenannter Tracking Error (<em>TE</em>) bezeichnet:</p>
<p><span class="math display">\[ (6a) \quad TE=Var(r_A)= Var(r_P-r_B) \quad bzw. \\
(6b) \quad TE=\sqrt{(Var(r_A))}=\sqrt{Var(r_P-r_B)} \]</span></p>
<p>Da für die Varianz einer Zufallsvariable <span class="math inline">\(X\)</span> gilt: <span class="math inline">\(Var(X)=E(X^2)-E(X)^2\)</span>, lässt sich Gleichung (6a) auch in Gleichung (7) überführen:</p>
<p><span class="math display">\[ (7) \quad Var(r_P-r_B)= E((r_P-r_B)^2)-E(r_P-r_B)^2 \\
\quad = E((r_P-r_B)^2)-E(\epsilon_P)^2=E((r_P-r_B)^2). \]</span></p>
<p>Wie im Kapitel zur relativen Optimierung dargestellt, lässt sich das auf die aktive Position zurückzuführende Risiko, das aktive Risiko, auch über Gleichung (8) definieren:</p>
<p><span class="math display">\[ (8) \quad \sigma^2_{AP}=w^T_A\Sigma w_A=Var(r_A) \]</span></p>
<p>wobei <span class="math inline">\(w_A\)</span> den Spaltenvektor der aktiven Gewichte <span class="math inline">\((w_A=w_P-w_B)\)</span> des Tracking Portfolios bezeichnet. Im Kontext des Index Tracking stellt also Gleichung (8) zugleich den Tracking Error dar. Der Tracking Error ist in diesem Kontext also die “aktive” Varianz des Tracking Portfolios. Somit gilt gemäß Gleichung (2) im Abschnitt “Aktives Beta” der relativen Optimierung auch:</p>
<p><span class="math display">\[ (9) \quad TE=\sigma^2_{AP}=\beta^2_{AP}\sigma^2_B + \sigma^2_{\epsilon_P} \]</span></p>
<p>Wegen der Nebenbedingung nach Gleichung (c) verkürzt sich der Ausdruck nach Gleichung (9) bei diesem Ansatz zu Gleichung (10).</p>
<p><span class="math display">\[ (10) \quad TE=\sigma^2_{AP}= \sigma^2_{\epsilon_P} \]</span></p>
<p>Mit der Zielfunktion nach Gleichung (1) wird also bei diesem Ansatz zur Bestimmung des Tracking Portfolios der Tracking Error minimiert, was dem üblichen Vorgehen zur Bestimmung eines Tracking Portfolios entspricht. Unter Berücksichtigung der mit Gleichung (7) hergeleiteten Beziehung gilt bei diesem Ansatz ferner:</p>
<p><span class="math display">\[ (10) \quad TE=\sigma^2_{AP}= \sigma^2_{\epsilon_P}=E((r_P-r_B)^2). \]</span></p>
<p>Die Zielfunktion nach Gleichung (1) lässt sich damit bei diesem Ansatz alternativ nach Gleichung (11) schreiben:</p>
<p><span class="math display">\[ (11) \quad ZF(w)= E((r_P-r_B)^2) \rightarrow \min_{w}! \]</span></p>
<p>Damit wird der inhaltliche Gehalt der Zielfunktion nach Gleichung (1) deutlich, denn die Minimierung von Gleichung (1) ist bei diesem Ansatz gleichbedeutend mit der Minimierung des Erwartungswertes der quadrierten Renditedifferenzen zwischen Tracking Portfolio und Benchmark. Insofern wird hier also der (erwartete) Mean Squared Error zwischen den Renditen des Tracking Portfolios und der Benchmark minimiert.</p>
<p>Das Problem der Bestimmung eines Tracking Portfolios lässt sich also <em>verfahrenstechnisch</em> insgesamt als Spezialfall der relativen Optimierung bei unterschiedlichen Anlageuniversen auffassen. Dazu sind lediglich eine Modifikation der Zielfunktion und das Hinzufügen der Nebenbedingung nach Gleichung (d) erforderlich.</p>
</section>
<section id="index-tracking-nach-markowitz-1987" class="level4" data-number="9.2.2.3">
<h4 data-number="9.2.2.3" class="anchored" data-anchor-id="index-tracking-nach-markowitz-1987"><span class="header-section-number">9.2.2.3</span> Index Tracking nach Markowitz (1987)</h4>
<p>Ausgangspunkt der folgenden Überlegungen ist wiederum ein Tracking Portfolio, welches in seiner Zusammensetzung (zwangsläufig) vom Target Portfolio abweichen muss, da sich die Anlageuniversen unterscheiden können und aus Kostengründen das Tracking Portfolio in der Regel mit weitaus weniger Assets gebildet werden soll als im Target Portfolio enthalten sind. Das Tracking Portfolio ist daher wie ein aktives Portfolio anzusehen, es besitzt in unvermeidlicher Weise eine aktive Rendite und ein aktives Risiko. Ein ideales Tracking Portfolio hat eine aktive Rendite und ein aktives Risiko von null.</p>
<p>Die aktive Position ist definiert als Differenzgewichte zwischen gehaltenem (Tracking) Portfolio <span class="math inline">\(P\)</span> und Target Portfolio <span class="math inline">\(B\)</span>, welches mit dem Benchmarkportfolio gleichgesetzt werden soll:</p>
<p><span class="math display">\[ (1) \quad w_A= w_P-w_B \]</span></p>
<p>Die erwartete aktive Rendite (<em>Bonus Return</em>) ist die erwartete Renditedifferenz zwischen (Tracking) Portfolio <span class="math inline">\(P\)</span> und Benchmark <span class="math inline">\(B\)</span> (das Target Portfolio):</p>
<p><span class="math display">\[ (2) \quad \mu_A= \mu_P-\mu_B=w^T_P \mu - w^T_B \mu = (w^T_P-w^T_B) \mu = w^T_A \mu \]</span></p>
<p>mit <span class="math inline">\(\quad \mu : \quad\)</span> Spaltenvektor der erwarteten Assetrenditen.</p>
<p>Das aktive Risiko (die aktive Varianz) ergibt sich als:</p>
<p><span class="math display">\[ (3) \quad Var(r_A)=\sigma^2_{AP}=w^T_A \Sigma w_A. \]</span></p>
<p>Dies ist zugleich die übliche Definition für den Tracking Error (vgl. Gleichung (8) oben):</p>
<p><span class="math display">\[ (4) \quad TE=Var(r_A) =Var(r_P-r_B). \]</span></p>
<p>Der Optimierungsansatz besteht nun darin, den Tracking Error unter Berücksichtigung verschiedener Nebenbedingungen zu minimieren. Die Zielfunktion lautet also:</p>
<p><span class="math display">\[ (5) \quad ZF(w)= TE= Var(r_A)=\sigma^2_{AP}=w^T_A \Sigma w_A \rightarrow \min_{w}! \]</span></p>
<p>Als zentrale Nebenbedingung wird dabei gefordert, dass die erwartete aktive Rendite ein gefordertes Niveau von <span class="math inline">\(\mu^*\)</span> besitzt, wobei im Regelfall <span class="math inline">\(\mu^*=0\)</span> gesetzt wird:</p>
<p><span class="math display">\[ (6) \quad \mu_A=w^T_A \mu = \mu^* (=0, i.d.R.) \]</span></p>
<p>Die weiteren Nebenbedingungen betreffen die Budgetrestriktion, die Nichtnegativitätsbedingung für die Anteilsgewichte (sofern Leerverkäufe ausgeschlossen sind), geforderte und zulässige Mindest- und Höchstanteilsgrenzen sowie ggf. weitere sinnvoll erscheinende Restriktionen.</p>
<p>In der praktischen Anwendung wird oftmals die Nebenbedingung nach Gleichung (6) vernachlässigt. Dies besitzt zunächst zwei Vorteile. Zum einen wird dadurch das Optimierungproblem vereinfacht. Zum anderen muss keine Schätzung der erwarteten Renditen bereitgestellt werden (die man ja auch gerade durch das Index Tracking vermeiden möchte). Allerdings kann jetzt eine Lösung resultieren, bei welcher die erwartete aktive Rendite negativ ausfällt.</p>
</section>
<section id="vergleich-beider-ansätze" class="level4" data-number="9.2.2.4">
<h4 data-number="9.2.2.4" class="anchored" data-anchor-id="vergleich-beider-ansätze"><span class="header-section-number">9.2.2.4</span> Vergleich beider Ansätze</h4>
<p>Der Markowitz Ansatz besitzt den vordergründigen Vorteil, mit wenigen und vergleichsweise unproblematisch zu schätzenden Größen auszukommen. Verzichtet man bei der Bestimmung des Tracking Portfolios auf die Nebenbedingung nach Gleichung (6), so ist lediglich eine Schätzung der zukünftigen Varianz-Kovarianzmatrix vorzunehmen. Diese kann mittels der empirischen Varianz-Kovarianzmatrix erfolgen, die in den meisten Fällen durchaus “brauchbare” Schätzungen liefert. Auf die kritische und zugleich sehr schwierige Schätzung der Erwartungswerte der Assetrenditen (auf den Vektor <span class="math inline">\(\mu\)</span>) wird konsequent verzichtet. Insofern kommt dieser Ansatz mit wenigen und in der Tendenz eher unkritischen sowie einfach zu schätzenden Inputparametern aus.</p>
<p>Im Gegensatz zu diesem Ansatz erfordert das Index Tracking gemäß relativer Optimierung zusätzlich die eher aufwändigere und zugleich kritischere Schätzung der Alpha- und Beta-Parameter der einzelnen Assets. Auf den ersten Blick ist damit dieser Ansatz im viel stärkeren Ausmaß der Schätzproblematik zukünftiger Größen ausgesetzt.</p>
<p>Der Markowitz-Ansatz ist jedoch nur deshalb nicht jener zusätzlichen Schätzproblematik ausgesetzt, weil diese schlichtweg ignoriert wird! Ohne Berücksichtigung der Nebenbedingung nach Gleichung (6) ist nämlich nicht ausgeschlossen, dass</p>
<ul>
<li>das Tracking Portfolio eine negative aktive Rendite (im Erwartungswert) besitzen wird und dass</li>
<li>es ein von eins abweichendes Beta haben kann, also eine ungewollte Timing-Komponente aufweisen wird.</li>
</ul>
<p>Will man diese beiden Effekte kontrollieren, muss die Nebenbedingung nach Gleichung (6) wieder hinzugefügt und eine Schätzung der Erwartungswerte der Assetrenditen vorgenommen werden. Vor diesem Hintergrund sind letztendlich beide Ansätze hinsichtlich der entstehenden Schätzproblematik gleichwertig.</p>
</section>
</section>
<section id="regression-unter-nebenbedingungen" class="level3" data-number="9.2.3">
<h3 data-number="9.2.3" class="anchored" data-anchor-id="regression-unter-nebenbedingungen"><span class="header-section-number">9.2.3</span> Regression unter Nebenbedingungen</h3>
<p>Dieses Verfahren kann als regressionsanalytischer Ansatz formuliert werden. Die Idee besteht darin, die für einen vergangenen Beobachtungszeitraum <span class="math inline">\(t=1, ..., T\)</span> erhobenen Renditen der Benchmark <span class="math inline">\(r_{Bt}\)</span> (abhängige Variable einer multivariaten linearen Kleinste-Quadrate Regression) durch die Renditen <span class="math inline">\(r_{it}\)</span> von <span class="math inline">\(N\)</span> Assets (unabhängige Variablen) zu erklären. Für einen beliebigen Zeitpunkt <span class="math inline">\(t\)</span> soll also gelten:</p>
<p><span class="math display">\[ (1) \quad r_{Bt}=w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}+\epsilon_t. \]</span></p>
<p>Das (Regression-) Residuum <span class="math inline">\(\epsilon_t\)</span> stellt hier den unsystematischen, nicht weiter erklärbaren, zufälligen Restanteil in Bezug auf die Benchmarkrendite dar. Der “Tracking Error” (Renditedifferenz, aktive Rendite) <span class="math inline">\(\epsilon_t\)</span> ergibt sich als einfache Umformung von Gleichung (1). Der Summenausdruck der rechten Seite von Gleichung (1) bzw. der Klammerausdruck in Gleichung (2) stellt dabei offensichtlich die Rendite des Tracking Portfolios dar:</p>
<p><span class="math display">\[ (2) \quad \epsilon_t=r_{Bt}-(w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}). \]</span></p>
<p>Das “optimale” Tracking Portfolio besitzt den minimalen “Tracking Error” über <span class="math inline">\(T\)</span> Perioden, erfüllt damit also folgende Bedingung:</p>
<p><span class="math display">\[ (3) \quad \Sigma^T_{t=1}\epsilon^2_t=\Sigma^T_{t=1}(r_{Bt}-(w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}))^2 \rightarrow \min_{w}!\ \]</span></p>
<p>Streng genommen beinhaltet Gleichung (3) eine <strong>ex post</strong> Forderung an das optimale Tracking Portfolio, wobei die Schätzung der unbekannten, gesuchten Gewichte <span class="math inline">\(w_{Pi}\)</span> anhand von ex ante Beobachtungen vorgenommen wird. Dabei wird die zentrale Annahme gesetzt, dass die in der Vergangenheit beobachteten Verhältnisse (Verteilung der Benchmark- und Assetrenditen) in derselben Weise weiterhin in der Zukunft Bestand haben werden. Die zu minimierende Zielfunktion lautet damit vollständig:</p>
<p><span class="math display">\[ (4) \quad ZF(w)=\Sigma^T_{t=1}\epsilon^2_t=\Sigma^T_{t=1}(r_{Bt}-(w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}))^2 \rightarrow \min_{w}!\ \]</span></p>
<p><strong>Vergleich mit den Verfahren der quadratischen Optimierung</strong></p>
<p>Während die Zielfunktion dieses Ansatzes in Gleichung (4) eine enge inhaltliche Verwandtschaft zu den vorhergehenden Ansätzen zeigt, ist die Schätztechnik eine völlig andere. Die beiden oben vorgestellten Verfahren der quadratischen Optimierung ermitteln das Tracking Portfolio bei genauer Betrachtung mithilfe zweier separater Schritte;</p>
<ol type="1">
<li>Ermittlung der benötigten Inputparameter für die Optimierung: Dies sind je nach Verfahren und Detaillierungsgrad die Schätzung der Varianz-Kovarianzmatrix <span class="math inline">\(\Sigma\)</span>, des erwarteten Renditevektors <span class="math inline">\(\mu\)</span> bzw. der Alpha- und Beta-Werte. Diese Schätzungen können, müssen aber nicht auf (einfachen) historischen Schätzungen basieren. Sie können auch mittels gänzlich anderer Verfahren und Vorgehensweisen bereitgestellt werden.</li>
<li>Ermittlung des Tracking Portfolios durch Optimierung einer Zielfunktion, basierend auf den Inputparametern aus Schritt 1.</li>
</ol>
<p>Der Regressionsansatz verzichtet dagegen auf ein zweistufiges Vorgehen. Die Ermittlung des Tracking Portfolios erfolgt direkt in einem Schritt über die Durchführung einer Kleinste-Quadrate Regression unter Nebenbedingungen. Der Vorteil besteht in dem verfahrenstechnisch sehr einfachen Vorgehen, welches umständliche Zwischenschritte der Schätzung benötigter Inputparameter vermeidet. Gleichzeitig liegt hierin aber auch der entscheidende Nachteil begründet. Bessere Schätzverfahren als die einfache historische Schätzung lassen sich hiermit nicht berücksichtigen. Die Ansätze der quadratischen Optimierung sind diesbezüglich wesentlich flexibler. Bessere Schätzverfahren für die benötigten Inputparameter können jederzeit durch Austausch der betreffenden Verfahren integriert werden, ohne das grundsätzliche Vorgehen zu ändern. Dies stellt einen wesentlichen Vorteil dar.</p>
</section>
<section id="lineare-optimierung" class="level3" data-number="9.2.4">
<h3 data-number="9.2.4" class="anchored" data-anchor-id="lineare-optimierung"><span class="header-section-number">9.2.4</span> Lineare Optimierung</h3>
<p>Beim im letzten Abschnitt vorgestellten Regressionsansatz zur Bestimmung eines Tracking Portfolios soll die Rendite des Target Portfolios (des Benchmarkportfolios <span class="math inline">\(B\)</span>) für beliebige Zeitpunkte <span class="math inline">\(t\)</span> (in der Zukunft) bestmöglich mittels <span class="math inline">\(N\)</span> Assets nachgebildet werden, wobei ein unvermeidbarer Restfehler <span class="math inline">\(\epsilon_t\)</span> verbleibt. Die unbekannten, noch gesuchten Größen sind hier die Anteilsgewichte <span class="math inline">\(w_{Pi}\)</span> der <span class="math inline">\(N\)</span> Assets im Tracking Portfolio:</p>
<p><span class="math display">\[ (1) \quad r_{Bt}=w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}+\epsilon_t. \]</span></p>
<p>Während die vorher beschriebenen Ansätze nun aber darauf basieren, im Idealfall die Restfehler <span class="math inline">\(\epsilon_t\)</span> auf <span class="math inline">\(\epsilon_t=0\)</span> für alle (zukünftigen) Zeitpunkte <span class="math inline">\(t\)</span> zu bringen, wird hier ein anderer Weg gewählt. Die aktive Rendite <span class="math inline">\(r_A\)</span> ist die Differenz zwischen Portfolio- und Benchmarkrendite. Definiert man ferner den Restfehler <span class="math inline">\(u_t=-\epsilon_t\)</span>, so lässt sich Gleichung (1) alternativ nach Gleichung (2) schreiben:</p>
<p><span class="math display">\[ (2) \quad r_{At}=r_{Pt}-r_{Bt}=u_t.  \]</span></p>
<p>Ein Investor wird natürlich darauf Wert legen, die Rendite der Benchmark mit dem Tracking Portfolio nicht zu unterschreiten. Er wird also <span class="math inline">\(u_t&lt;0\)</span> auf jeden Fall vermeiden wollen. Dagegen ist es plausibel anzunehmen, dass positive Abweichungen der Rendite des Tracking Portfolios von der Benchmark, also <span class="math inline">\(u_t&gt;0\)</span>, durchaus erwünscht sind. Das ideale Tracking Portfolio besitzt nach dieser Auffassung die minimale Summe der Absolutbeträge aller negativen aktiven Renditen (bzw. Restfehler <span class="math inline">\(u_t\)</span>). Es minimiert die erwarteten Verluste des Investors, erhält aber alle Gewinnchancen. Die Zielfunktion zur Bestimmung des Tracking Portfolios lautet damit:</p>
<p><span class="math display">\[ (3) \quad ZF(w)=\Sigma^T_{t=1\\r_{Pt}&lt;r_{Bt}} |r_{Pt}-r_{Bt}| \rightarrow \min_{w}! \]</span></p>
<p>Der grundlegende Ansatz lautet also: Bestimme das Tracking Portfolio derart, dass die Summe der Absolutbeträge der (zukünftigen) negativen Renditeabweichungen gegenüber der Benchmark minimiert wird! Dieser Ansatz basiert auf einem <em>einseitigen</em> Risikoverständnis, indem nur <em>Unterschreitungen</em> der Benchmarkrendite als unerwünschte Zustände aufgefasst werden, deren Eintreten vermieden werden soll.</p>
<p>Die Zielfunktion nach Gleichung (3) bezieht sich streng genommen wiederum auf die Zukunft, beinhaltet also ex post Größen. Für die Optimierung des Tracking Portfolios muss diese wiederum geschätzt werden, wobei die Schätzung üblicherweise anhand von <span class="math inline">\(T\)</span> zurückliegenden Beobachtungsperioden für Benchmark- und Assetrenditen vorgenommen wird (historisch basierte Schätzung).</p>
<section id="implementierung-der-zielfunktion-über-die-hilfsvariablen-d_t-und-d-_t" class="level4" data-number="9.2.4.1">
<h4 data-number="9.2.4.1" class="anchored" data-anchor-id="implementierung-der-zielfunktion-über-die-hilfsvariablen-d_t-und-d-_t"><span class="header-section-number">9.2.4.1</span> Implementierung der Zielfunktion über die Hilfsvariablen <span class="math inline">\(d^+_t\)</span> und <span class="math inline">\(d^-_t\)</span></h4>
<p>Für die weitere Darstellung werden zwei Hilfsvariablen eingeführt. Die Hilfsvariable <span class="math inline">\(d^+_t\)</span> bezeichne die positive Differenz zwischen der Rendite des Tracking Portfolios und der der Benchmark als positive Zahl. Umgekehrt wird mit der Hilfsvariable <span class="math inline">\(d^-_t\)</span> die negative Differenz zwischen der Rendite des Tracking Portfolios und der der Benchmark, ebenfalls als positive Zahl, bezeichnet. Die aktive Rendite <span class="math inline">\(r_{At}\)</span> bzw. der Restfehler <span class="math inline">\(u_t\)</span> lässt sich mithilfe dieser beiden Hilfsvariablen schreiben als</p>
<p><span class="math display">\[ (4) \quad r_{At}=u_t=d^+_t-d^-_t \]</span></p>
<p>wobei gilt</p>
<p><span class="math display">\[ (5a) \quad d^+_t=r_{Pt}-r_{Bt},  \quad wenn \quad r_{Pt}&gt;r_{Bt} \\
d^+_t=0 \quad sonst \]</span></p>
<p><span class="math display">\[ (5b) \quad d^-_t=r_{Bt}-r_{Pt},  \quad wenn \quad r_{Pt}&lt;r_{Bt} \\
d^-_t=0 \quad sonst. \]</span></p>
<p>Per Definition gilt: <span class="math inline">\(d^+_t \geq 0\)</span> und <span class="math inline">\(d^-_t \geq 0\)</span>. Außerdem folgt aus <span class="math inline">\(d^+_t&gt;0\)</span> sofort <span class="math inline">\(d^-_t=0\)</span> und umgekehrt, wenn <span class="math inline">\(d^-_t&gt;0\)</span>, dann ist <span class="math inline">\(d^+_t=0\)</span>. Für jeden Zeitpunkt <span class="math inline">\(t\)</span> gilt damit Gleichung (6), indem Gleichung (4) in Gleichung (2) eingesetzt wird:</p>
<p><span class="math display">\[ (6) \quad r_{Pt}-r_{Bt}=d^+_t-d^-_t.  \]</span></p>
<p>Die Gleichungen (7a) und (7b) sind äquivalent zu Gleichung (6) und gelten ebenfals für jeden Zeitpunkt <span class="math inline">\(t\)</span>:</p>
<p><span class="math display">\[ (7a) \quad r_{Pt}-r_{Bt}-d^+_t+d^-_t=0 \quad bzw. \\
(7b) \quad r_{Pt}-d^+_t+d^-_t=r_{Bt}.\]</span></p>
<p>Setzt man in (7b) für die Rendite des Tracking Portfolios den bekannten Ausdruck <span class="math inline">\(\Sigma^N_{i=1} w_{Pi}r_{it}\)</span> ein, so ergibt sich die Variante (7c):</p>
<p><span class="math display">\[ (7c) \quad \Sigma^N_{i=1} w_{Pi}r_{it}-d^+_t+d^-_t=r_{Bt} . \]</span></p>
<p>Die zu minimierende Zielfunktion nach Gleichung (3) lässt sich unter Verwendung der eingeführten Hilfsvariablen alternativ als Gleichung (8) schreiben:</p>
<p><span class="math display">\[ (8) \quad ZF=\Sigma^T_{t=1} d^-_t  \rightarrow \min! \]</span></p>
<p>Im Zuge der Optimierung sind die Werte der folgenden gesuchten Variablen zu bestimmen:</p>
<ul>
<li>die <span class="math inline">\(N\)</span> Anteilsgewichte der Assets <span class="math inline">\(w_{Pi}\)</span>.</li>
<li>die <span class="math inline">\(T\)</span> Werte für die positiven Renditeabweichungen <span class="math inline">\(d^+_t\)</span> (bzw. positiven aktiven Renditen <span class="math inline">\(r_{At}\)</span> bzw. positiven Restfehler <span class="math inline">\(u_t\)</span>) und</li>
<li>die <span class="math inline">\(T\)</span> Werte für die negativen Renditeabweichungen <span class="math inline">\(d^-_t\)</span> (bzw. negativen aktiven Renditen <span class="math inline">\(r_{At}\)</span> bzw. negativen Restfehler <span class="math inline">\(u_t\)</span>),</li>
</ul>
<p>also die Werte von <span class="math inline">\(N+T+T\)</span> Problemvariablen. Der Optimierungsansatz besteht hier darin, die Werte der Anteilsgewichte <span class="math inline">\((w_{Pi})\)</span> und der Restfehler <span class="math inline">\((d^+_t-d^-_t)\)</span> gemeinsam so zu ermitteln, dass</p>
<ul>
<li>in allen <span class="math inline">\(t=1, ..., T\)</span> Perioden die Rendite des Tracking Portfolios abzüglich des Restfehlers der Rendite des Benchmarkportfolios entspricht, also Gleichung (7c) für alle <span class="math inline">\(T\)</span> Perioden erfüllt ist, und</li>
<li>die Summe der negativen Restfehler <span class="math inline">\(d^-_t\)</span> dabei ein Minimum annimmt.</li>
</ul>
<p>Der Optimierungsansatz zur Bestimmung des Tracking Portfolios lautet damit zusammengefasst wie folgt:</p>
<p><span class="math display">\[ (9) \quad ZF=\Sigma^T_{t=1} d^-_t  \rightarrow \min! \]</span></p>
<p>Die zentralen Nebenbedingungen lauten dabei:</p>
<p><span class="math display">\[
\begin{split}
&amp; \text{(10)}\quad \Sigma^N_{i=1} w_{Pi}r_{it}-d^+_t+d^-_t=r_{Bt} \qquad \text{für alle Zeitpunkte} \space t=1, ..., T \\
&amp; \text{(11a)}\quad d^+_t \geq0 \qquad \text{für alle Zeitpunkte} \space t=1, ..., T \\
&amp; \text{(11b)}\quad d^-_t \geq0 \qquad \text{für alle Zeitpunkte} \space t=1, ..., T. \\
\end{split}
\]</span></p>
<p>Hinzu kommen die üblichen Nebenbedingungen wie die Budgetrestriktion, das Leerverkaufsverbot, und eventuell weitere Restriktionen wie geforderte Mindestanteile und zulässige Höchstanteile von Assets im Tracking Portfolio.</p>
<p>Auch bei diesem Ansatz zur Bestimmung eines Tracking Portfolios besteht eine Schätzproblematik. Die eigentlich zu minimierende Zielfunktion nach Gleichung (3) bezieht sich auf ex post Größen und wird zum Zwecke der konkreten Bestimmung des Tracking Portfolios über ihre ex ante Formulierung, d.h. anhand vergangener Beobachtungen, geschätzt. Die Güte der Schätzung über ihre ex ante Variante ist also dafür entscheidend, ob die Erwartungen an das Tracking Portfolio später auch tatsächlich erfüllt werden. Ein weiterer Aspekt der Schätzproblematik betrifft die Anzahl der gesuchten (Problem-) Variablen bei diesem Ansatz. Neben den eigentlich interessierenden <span class="math inline">\(N\)</span> Anteilsgewichten <span class="math inline">\(w_{Pi}\)</span> des Tracking Portfolios sind bei diesem Optimierungsansatz ferner die Werte der <span class="math inline">\(T\)</span> Hilfsvariablen <span class="math inline">\(d^+_t\)</span> und <span class="math inline">\(d^-_t\)</span> zu bestimmen. Dies sind zusammen <span class="math inline">\(N+2T\)</span> freie Parameter des Optimierungsproblems. Werden beispielsweise für das Tracking Portfolio potenziell 30 Assets vorgesehen und soll die Schätzung der Zielfunktion über einen Beobachtungszeitraum von 240 Monaten auf Basis von Monatsrenditen vorgenommen werden, so resultieren daraus 510 freie, im Zuge der Optimierung zu bestimmende Parameter. Da es sich um ein lineares Optimierungsproblem handelt stellt dies in der Regel aber kein Problem dar.</p>
</section>
</section>
<section id="schätzproblematik-der-optimierungsparameter" class="level3" data-number="9.2.5">
<h3 data-number="9.2.5" class="anchored" data-anchor-id="schätzproblematik-der-optimierungsparameter"><span class="header-section-number">9.2.5</span> Schätzproblematik der Optimierungsparameter</h3>
<p>Ein wesentlicher Beweggrund für ein passives Portfoliomanagement ist die Überzeugung, über nicht hinreichende Prognosefähigkeiten zu verfügen, deren Güte im Zuge der aktiven Umsetzung es erlauben würde, ausreichende systematische Extragewinne zu erzielen. Konsequenterweise wird dann auf Prognosen (Schätzungen zukünftiger Größen) verzichtet und die vorgegebene Benchmark über ein Tracking Portfolio verfolgt.</p>
<p>Die nähere Analyse der Verfahren zur Bestimmung von Tracking Portfolios offenbart aber, dass sobald das passive Management auf die approximative Nachbildung (Sampling) der Benchmark zurückgreift, dieselbe Prognoseproblematik wie beim aktiven Management entsteht. Was wird gewonnen?</p>
<p>Tendenziell wird bei einem Tracking Portfolio, welches</p>
<ul>
<li>dasselbe Anlageuniversum besitzt wie die Benchmark,</li>
<li>viele Assets beinhaltet und hinsichtlich der Assetgewichte</li>
<li>eng an die Benchmark orientiert ist,</li>
</ul>
<p>die Schätzproblematik weniger ins Gewicht fallen, als bei einem Tracking Portfolio, welches</p>
<ul>
<li>aus einem abweichenden Anlageuniversum zusammengestellt wird bzw. werden muss,</li>
<li>eher wenige Assets beinhaltet und damit bezüglich einbezogener Assets und deren Anteilsgewichte</li>
<li>deutlich von der Struktur der Benchmark abweicht.</li>
</ul>
</section>
</section>
<section id="beginn-der-fallstudie" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="beginn-der-fallstudie"><span class="header-section-number">9.3</span> Beginn der Fallstudie</h2>
<p>Wir starten mit dem Import der benötigten Pakete.</p>
<div id="cell-7" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> statsmodels.regression.linear_model <span class="im">as</span> sm</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> statsmodels.tools.tools <span class="im">as</span> sm2</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<section id="laden-und-beschreiben-der-datenbasis" class="level3" data-number="9.3.1">
<h3 data-number="9.3.1" class="anchored" data-anchor-id="laden-und-beschreiben-der-datenbasis"><span class="header-section-number">9.3.1</span> Laden und Beschreiben der Datenbasis</h3>
<p>Der verwendete Datensatz enthält Kurshistorien der folgenden zehn Aktien: Danone, Siemens, BASF, L’Oreal, Allianz, Telecom Italia, Banco Santander, Total, BMW, Vivendi. Zudem ist als elfte Spalte die Indexhistorie des Euro Stoxx 50 verfügbar.</p>
<p>Die Aufgabenstellung der Fallstudie besteht also darin, auf Basis der zehn Einzeltitel das optimale Tracking Portfolio für das Target Portfolio Euro Stoxx 50 zu erstellen.</p>
<p>Die Datengrundlage hierfür sind 111 Monatsschlusskurse (“Adjusted Close”) über den Zeitraum vom 31.12.2002 bis zum 28.2.2012.</p>
<div id="cell-9" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>frame <span class="op">=</span> pd.read_excel(<span class="st">'Kapitel A3_4.xlsx'</span>, <span class="st">'Tabelle1'</span>, index_col<span class="op">=</span><span class="dv">0</span>, parse_dates<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-10" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>frame.head(<span class="dv">4</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">2002-12-31</th>
<td>30.2427</td>
<td>40.50</td>
<td>18.040</td>
<td>72.55</td>
<td>82.025</td>
<td>2.0558</td>
<td>5.8537</td>
<td>33.5794</td>
<td>28.92</td>
<td>15.39</td>
<td>2386.41</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">2003-01-31</th>
<td>27.6478</td>
<td>38.15</td>
<td>17.260</td>
<td>64.30</td>
<td>66.860</td>
<td>2.0199</td>
<td>5.1466</td>
<td>30.9888</td>
<td>27.26</td>
<td>15.64</td>
<td>2248.17</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2003-02-28</th>
<td>25.9021</td>
<td>36.78</td>
<td>16.910</td>
<td>59.90</td>
<td>60.137</td>
<td>1.8927</td>
<td>5.3256</td>
<td>30.2486</td>
<td>26.00</td>
<td>13.02</td>
<td>2140.73</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">2003-03-31</th>
<td>27.2939</td>
<td>37.80</td>
<td>17.055</td>
<td>55.50</td>
<td>41.080</td>
<td>2.0074</td>
<td>5.2361</td>
<td>28.6202</td>
<td>25.44</td>
<td>12.18</td>
<td>2036.86</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="relative-optimierung-und-index-tracking-1" class="level3" data-number="9.3.2">
<h3 data-number="9.3.2" class="anchored" data-anchor-id="relative-optimierung-und-index-tracking-1"><span class="header-section-number">9.3.2</span> Relative Optimierung und Index Tracking</h3>
<p>Die grundsätzliche Vorgehensweise entspricht der der <strong>relativen Optimierung bei unterschiedlichen Anlageuniversen</strong>. Auf Basis der Überschussrenditen ermitteln wir den Vektor der zukünftigen erwarteten Assetrenditen <span class="math inline">\(\mu\)</span> und die zukünftige Varianz-Kovarianzmatrix <span class="math inline">\(\Sigma\)</span> nach der Methode der <strong>historisch basierten Schätzung</strong>.</p>
<p><strong>Hinweis</strong>: Bei den oben diskutierten Verfahren des Index Trackings ist es unbedeutend, ob von absoluten oder überschüssigen Renditen ausgegangen wird. Wichtig ist nur die konsistente Verwendung.</p>
<p><strong>Schätz- vs.&nbsp;Validierungszeitraum:</strong> Das vorhandene Datenmaterial umfasst insgesamt 111 monatliche Beobachtungen für Kurse bzw. Indexstände, aus denen sich 110 (diskrete) Monatsrenditen für die Einzeltitel und den Index berechnen lassen. Um die Bedeutung der Schätzproblematik zu illustrieren, wird das Datenmaterial in einen Schätzzeitraum, bestehend aus den ersten 60 Monatsrenditen, und einen Validierungszeitraum, bestehend aus den letzten 50 Monatsrenditen, unterteilt. Die Bestimmung der Tracking Portfolios erfolgt stets auf Basis der ersten 60 Beobachtungen (Schätzzeitraum). Nach der Bestimmung des Tracking Portfolios wird anhand des Validierungszeitraums berechnet, welche (mittlere) aktive Rendite und zugehörige Varianz (Tracking Error) das Tracking Portfolio besessen hätte. Bei perfekten Schätzungen der Inputparameter für die jeweiligen Verfahren müssten im Idealfall die Werte für den <em>geschätzten</em> ex ante Tracking Error (anhand des Schätzzeitraums) in etwa mit dem tatsächlichen, ex post Tracking Error des Validierungszeitraums übereinstimmen. Dabei kann zwar eine einzelne Fallstudie keine generellen Aussagen über die Güte der einzelnen Verfahren zulassen, aber dennoch die grundsätzliche Problematik illustrieren.</p>
<div id="cell-12" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># calculation based on discrete returns</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>returns <span class="op">=</span> frame.pct_change().dropna()</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>rf <span class="op">=</span> (<span class="dv">1</span><span class="op">+</span><span class="fl">0.04</span>)<span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">12</span>)<span class="op">-</span><span class="dv">1</span> <span class="co"># risk-free rate assumed 4% p.a.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>ex_returns <span class="op">=</span> returns <span class="op">-</span> rf</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co"># important: use only the first 60 returns!</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>means <span class="op">=</span> ex_returns.iloc[:<span class="dv">60</span>,:].mean().values<span class="op">*</span><span class="dv">100</span><span class="op">*</span><span class="dv">12</span> <span class="co"># annualised</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>Sigma <span class="op">=</span> ex_returns.iloc[:<span class="dv">60</span>,:].cov().values <span class="co"># non-annualised</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Danach berechnen wir auf Basis univariater Regressionen die Alpha- und Beta-Werte relativ zur Benchmark “Euro Stoxx 50”.</p>
<div id="cell-14" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># calculating vectors of alphas and betas</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>alpha <span class="op">=</span> np.zeros(ex_returns.columns.shape)</span>
<span id="cb5-3"><a href="#cb5-3"></a>beta <span class="op">=</span> np.zeros(ex_returns.columns.shape)</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a>x1 <span class="op">=</span> ex_returns[<span class="st">'EuroStoxx 50'</span>]</span>
<span id="cb5-6"><a href="#cb5-6"></a>x2 <span class="op">=</span> sm2.add_constant(x1)</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="cf">for</span> idx, ticker <span class="kw">in</span> <span class="bu">enumerate</span>(ex_returns.columns):</span>
<span id="cb5-9"><a href="#cb5-9"></a>    reg <span class="op">=</span> sm.OLS(ex_returns[ticker].iloc[:<span class="dv">60</span>], x2.iloc[:<span class="dv">60</span>]).fit()</span>
<span id="cb5-10"><a href="#cb5-10"></a>    parameter <span class="op">=</span> np.asarray(reg.params)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    alpha[idx] <span class="op">=</span> parameter[<span class="dv">0</span>]</span>
<span id="cb5-12"><a href="#cb5-12"></a>    beta[idx] <span class="op">=</span> parameter[<span class="dv">1</span>]</span>
<span id="cb5-13"><a href="#cb5-13"></a>df <span class="op">=</span>pd.DataFrame({<span class="st">'Alpha'</span>: alpha, <span class="st">'Beta'</span>: beta}, index<span class="op">=</span>ex_returns.columns)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-15" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="8">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Alpha</th>
<th data-quarto-table-cell-role="th">Beta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">Danone</th>
<td>4.099316e-03</td>
<td>0.594364</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Siemens</th>
<td>5.791281e-03</td>
<td>1.275000</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BASF</th>
<td>7.575579e-03</td>
<td>1.030921</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">L'Oreal</th>
<td>-4.921888e-03</td>
<td>1.073291</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Allianz</th>
<td>-6.305175e-03</td>
<td>2.479420</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<td>-5.946760e-03</td>
<td>0.570475</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Banco Santander</th>
<td>2.719632e-03</td>
<td>1.214706</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Total</th>
<td>1.871939e-03</td>
<td>0.600654</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BMW</th>
<td>-4.269235e-03</td>
<td>1.206465</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Vivendi</th>
<td>1.890327e-03</td>
<td>1.120708</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
<td>2.385245e-18</td>
<td>1.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="cell-16" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>alpha <span class="op">=</span> np.matrix(alpha)</span>
<span id="cb7-2"><a href="#cb7-2"></a>beta <span class="op">=</span> np.matrix(beta)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p><strong>Wichtige Analogie zum Fall der relativen Optimierung bei unterschiedlichem Anlageuniversum:</strong></p>
<p>Das Anlageuniversum in der Fallstudie hat elf Assets, nämlich die betrachteten zehn Einzeltitel sowie den EuroStoxx50 Index als “virtuelle” Anlage. Die historisch basierte Berechnung von <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\Sigma\)</span>, <span class="math inline">\(\alpha\)</span>, und <span class="math inline">\(\beta\)</span> erfolgte oben bereits für diese elf Anlagen.</p>
<p>Im nächsten Schritt muss der Vektor der (Target Portfolio-) Benchmark-Gewichte derart ausgestaltet sein, dass die ersten zehn Gewichte (für die Einzeltitel) den Wert null und das letzte Gewicht (für den EuroStoxx50) den Wert eins zugewiesen bekommen.</p>
<p>Als willkürlich gewählte Startlösung wird wieder eine gleichmäßige Aufteilung der Anteilsgewichte auf alle zur Verfügung stehenden Einzeltitel (ein <em>naives Tracking Portfolio</em>) zugrunde gelegt. Hierfür muss der Vektor der Startgewichte für das Tracking Portfolio jeweils den Wert <span class="math inline">\(1/10\)</span> (<code>1/(means.shape[0]-1)</code>) auf den ersten zehn Positionen enthalten, und den Wert null auf der letzten Position.</p>
<div id="cell-18" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># calculation of weight vector for tracking portfolio and benchmark/target</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"># using EuroStoxx50 as a benchmark implies that all benchmark weights (first N-1)</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co"># elements are zero and 1 for EuroStoxx50 (last element)</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>bench_w <span class="op">=</span> np.zeros(means.shape)</span>
<span id="cb8-5"><a href="#cb8-5"></a>bench_w[<span class="op">-</span><span class="dv">1</span>]<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>bench_w <span class="op">=</span> np.matrix(bench_w)</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co"># vector of starting weights is equally-weighted for the first N-1 </span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co"># elements and zero for the last element</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>Weight_start <span class="op">=</span> np.zeros(means.shape)</span>
<span id="cb8-11"><a href="#cb8-11"></a>Weight_start[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]<span class="op">=</span><span class="dv">1</span><span class="op">/</span>(means.shape[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb8-12"><a href="#cb8-12"></a>Weight_start <span class="op">=</span> np.matrix(Weight_start)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die Zielfunktion minimiert das residuale Risiko <span class="math inline">\(\sigma^2_{\epsilon_P} =w_P^T\Sigma w_P-(w_P^T\beta)^2*w_B^T\Sigma w_B\)</span>, welches unter der geforderten Nebenbedingung <span class="math inline">\((\beta_P=1)\)</span> dem aktiven Risiko <span class="math inline">\(\sigma^2_{AP}\)</span> und dem Tracking Error <span class="math inline">\(E((r_P-r_B)^2)\)</span> entspricht.</p>
<p>Die Zielfunktion wird über die Funktion <code>tracking_error1</code> implementiert.</p>
<p>Die zusätzliche Nebenbedingung (<span class="math inline">\(\alpha_P=0 \rightarrow\)</span> keine Selektion) wird ähnlich wie die Budgetrestriktion und die “No Timing” <span class="math inline">\((\beta_P=1)\)</span> Restriktion in Form einer <code>lambda</code>-Funktion geschrieben und dem Tuple <code>cons</code> der Nebenbedingungs-Dictionaries hinzugefügt.</p>
<div id="cell-20" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># target function: minimize 'residual risk' !</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># alpha, beta, bench_w have to be defined prior as matrices</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">def</span> tracking_error1(w, Sigma):</span>
<span id="cb9-4"><a href="#cb9-4"></a>    port_w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    port_alpha <span class="op">=</span> (port_w<span class="op">*</span>alpha.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb9-6"><a href="#cb9-6"></a>    port_beta <span class="op">=</span> (port_w<span class="op">*</span>beta.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb9-7"><a href="#cb9-7"></a>    port_var <span class="op">=</span> (port_w <span class="op">*</span> Sigma<span class="op">*</span>port_w.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb9-8"><a href="#cb9-8"></a>    bench_var <span class="op">=</span> (bench_w <span class="op">*</span> Sigma <span class="op">*</span> bench_w.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb9-9"><a href="#cb9-9"></a>    resid_var <span class="op">=</span> port_var <span class="op">-</span> port_beta<span class="op">**</span><span class="dv">2</span><span class="op">*</span>bench_var</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="cf">return</span> resid_var <span class="co"># minimization problem</span></span>
<span id="cb9-11"><a href="#cb9-11"></a></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">def</span> port_beta(w,beta):</span>
<span id="cb9-13"><a href="#cb9-13"></a>    port_w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>    port_beta <span class="op">=</span> (port_w<span class="op">*</span>beta.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="cf">return</span> port_beta</span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a>cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span>},</span>
<span id="cb9-18"><a href="#cb9-18"></a>        {<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: (np.matrix(x)<span class="op">*</span>beta.T)[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>},</span>
<span id="cb9-19"><a href="#cb9-19"></a>        {<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: (np.matrix(x)<span class="op">*</span>alpha.T)[<span class="dv">0</span>,<span class="dv">0</span>]})</span>
<span id="cb9-20"><a href="#cb9-20"></a></span>
<span id="cb9-21"><a href="#cb9-21"></a>bound <span class="op">=</span> (<span class="fl">0.05</span>,<span class="fl">0.40</span>)</span>
<span id="cb9-22"><a href="#cb9-22"></a>bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(alpha.shape[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb9-23"><a href="#cb9-23"></a>bounds <span class="op">+=</span> ((<span class="fl">0.0</span>, <span class="fl">1e-10</span>), ) <span class="co"># weight of the benchmark is fixed to zero</span></span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a>res1 <span class="op">=</span> minimize(tracking_error1, Weight_start, args<span class="op">=</span>Sigma,</span>
<span id="cb9-26"><a href="#cb9-26"></a>                        method<span class="op">=</span><span class="st">'SLSQP'</span>, bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>,</span>
<span id="cb9-27"><a href="#cb9-27"></a>               options<span class="op">=</span>{<span class="st">'disp'</span>: <span class="va">True</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.0001331023399440785
            Iterations: 34
            Function evaluations: 408
            Gradient evaluations: 34</code></pre>
</div>
</div>
<div id="cell-21" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>pd.DataFrame([<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res1.x],index<span class="op">=</span>ex_returns.columns).T</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>0.05</td>
<td>0.05</td>
<td>0.0915</td>
<td>0.1587</td>
<td>0.05</td>
<td>0.1203</td>
<td>0.0987</td>
<td>0.1969</td>
<td>0.0585</td>
<td>0.1254</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Die beiden zentralen Nebenbedingungen werden eingehalten. Das Tracking Portfolio Alpha ist null und das Beta ist eins.</p>
<div id="cell-23" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">round</span>(port_beta(res1.x,beta), <span class="dv">6</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>1.0</code></pre>
</div>
</div>
<div id="cell-24" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="bu">round</span>((np.matrix(res1.x)<span class="op">*</span>alpha.T)[<span class="dv">0</span>,<span class="dv">0</span>], <span class="dv">6</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>0.0</code></pre>
</div>
</div>
</section>
<section id="index-tracking-nach-markowitz-1987-1" class="level3" data-number="9.3.3">
<h3 data-number="9.3.3" class="anchored" data-anchor-id="index-tracking-nach-markowitz-1987-1"><span class="header-section-number">9.3.3</span> Index Tracking nach Markowitz (1987)</h3>
<p>Die Zielfunktion besteht in der Minimierung des Tracking Errors (aktives Risiko):</p>
<p><span class="math display">\[ \quad ZF(w)= TE= Var(r_A)=\sigma^2_{AP}=w^T_A \Sigma w_A \rightarrow \min_{w}! \]</span></p>
<p>Als zentrale Nebenbedingung wird gefordert:</p>
<p><span class="math display">\[ \quad \mu_A=w^T_A \mu =0. \]</span></p>
<p><code>tracking_error2</code> implementiert die Zielfunktion und <code>active_return</code> die Berechnung der erwarteten aktiven Rendite. Die Nebenbedingung wird in Form einer <code>lambda</code>-Funktion geschrieben und dem Tuple <code>cons</code> der Nebenbedingungs-Dictionaries hinzugefügt.</p>
<div id="cell-26" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># target function: minimize 'active risk'!</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co"># N.B.: expected active return = 0</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">def</span> tracking_error2(w, Sigma):</span>
<span id="cb16-4"><a href="#cb16-4"></a>    port_w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    active_weights <span class="op">=</span> port_w <span class="op">-</span> bench_w</span>
<span id="cb16-6"><a href="#cb16-6"></a>    active_risk <span class="op">=</span> (active_weights <span class="op">*</span> Sigma <span class="op">*</span> active_weights.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="cf">return</span> active_risk <span class="co"># minimization problem</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>    </span>
<span id="cb16-9"><a href="#cb16-9"></a>means <span class="op">=</span> np.matrix(means) <span class="co"># means is a row (not column!) vector</span></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">def</span> active_return(w):</span>
<span id="cb16-12"><a href="#cb16-12"></a>    active_weights <span class="op">=</span> np.matrix(w) <span class="op">-</span> bench_w</span>
<span id="cb16-13"><a href="#cb16-13"></a>    active_return <span class="op">=</span> (active_weights <span class="op">*</span> means.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="cf">return</span> active_return </span>
<span id="cb16-15"><a href="#cb16-15"></a></span>
<span id="cb16-16"><a href="#cb16-16"></a>cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span>},</span>
<span id="cb16-17"><a href="#cb16-17"></a>        {<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: active_return(x)})</span>
<span id="cb16-18"><a href="#cb16-18"></a></span>
<span id="cb16-19"><a href="#cb16-19"></a>bound <span class="op">=</span> (<span class="fl">0.05</span>,<span class="fl">0.40</span>)</span>
<span id="cb16-20"><a href="#cb16-20"></a>bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(alpha.shape[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb16-21"><a href="#cb16-21"></a>bounds <span class="op">+=</span> ((<span class="fl">0.0</span>, <span class="fl">1e-10</span>), ) <span class="co"># weight of the benchmark is fixed to zero</span></span>
<span id="cb16-22"><a href="#cb16-22"></a></span>
<span id="cb16-23"><a href="#cb16-23"></a>res2 <span class="op">=</span> minimize(tracking_error2, Weight_start, args<span class="op">=</span>Sigma,</span>
<span id="cb16-24"><a href="#cb16-24"></a>                method<span class="op">=</span><span class="st">'SLSQP'</span>, bounds<span class="op">=</span>bounds, </span>
<span id="cb16-25"><a href="#cb16-25"></a>                constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>, options<span class="op">=</span>{<span class="st">'disp'</span>: <span class="va">True</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.00013298691074338728
            Iterations: 39
            Function evaluations: 468
            Gradient evaluations: 39</code></pre>
</div>
</div>
<div id="cell-27" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>pd.DataFrame([<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res2.x],index<span class="op">=</span>ex_returns.columns).T</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>0.05</td>
<td>0.05</td>
<td>0.0902</td>
<td>0.162</td>
<td>0.05</td>
<td>0.1178</td>
<td>0.1001</td>
<td>0.1916</td>
<td>0.0627</td>
<td>0.1257</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Die gefundene Lösung genügt allen Nebenbedingungen und besitzt einen minimalen, <em>geschätzten</em> Tracking Error.</p>
<div id="cell-29" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># expected active return</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="bu">round</span>(((np.matrix(res2.x)<span class="op">-</span>bench_w)<span class="op">*</span>means.T)[<span class="dv">0</span>,<span class="dv">0</span>], <span class="dv">4</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>-0.0</code></pre>
</div>
</div>
<div id="cell-30" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="co"># tracking error</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>tracking_error2(res2.x, Sigma)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>0.00013298691074338728</code></pre>
</div>
</div>
<p>Insofern ist nunmehr die Frage interessant, wie dieses Tracking Portfolio im folgenden Validierungszeitraum abgeschnitten hätte. Um dies zu analysieren, berechnen wir auf Basis der optimierten Gewichte die realisierte aktive Rendite (Variable <code>realized_act_ret</code>) über den gesamten Zeitraum, und weisen dann separat für beide Zeiträume die Varianz und den Mittelwert von <code>realized_act_ret</code> aus.</p>
<div id="cell-32" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># calculation of realized TE and mean active return for </span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="co"># estimation and validation period</span></span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># realized active return</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>realized_act_ret <span class="op">=</span> ex_returns.multiply(res2.x).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)<span class="op">-</span>ex_returns[<span class="st">'EuroStoxx 50'</span>]</span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co"># estimation period</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>realized_eTE <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].var() <span class="co"># equals tracking_error2(res2.x, Sigma)</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>realized_eAR <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].mean()</span>
<span id="cb23-10"><a href="#cb23-10"></a></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="co"># validation period</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>realized_vTE <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].var() </span>
<span id="cb23-13"><a href="#cb23-13"></a>realized_vAR <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].mean() </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-33" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>realized_eTE</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>0.00013298691074338696</code></pre>
</div>
</div>
<div id="cell-34" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>realized_vTE</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>0.0004602271724062247</code></pre>
</div>
</div>
<div id="cell-35" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>realized_eAR</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>-9.776323269446627e-16</code></pre>
</div>
</div>
<div id="cell-36" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>realized_vAR</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>0.005638212117542039</code></pre>
</div>
</div>
<p><strong>Diskussion der Schätzproblematik</strong></p>
<p>Das eigentlich auf die Zukunft (hier repräsentiert durch den Validierungszeitraum) bezogene Tracking Portfolio hält gemäß der <em>Schätzung</em> im Schätzzeitraum die Nebenbedingung einer erwarteten aktiven Rendite von null ein und besitzt einen minimalen (<em>geschätzten</em>) Tracking Error. Im Validierungszeitraum wird dann aber tatsächlich die Nebenbedingung <span class="math inline">\(\mu_A=0\)</span> deutlich verletzt. Der ex post Tracking Error im Validierungszeitraum ist mehr als dreimal höher als nach seiner Schätzung.</p>
<p>Diese Ergebnisse sollten allerdings nicht falsch interpretiert werden. Sie belegen weder die Untauglichkeit des Markowitz-Verfahrens noch die Unsinnigkeit des Index Tracking. Sie illustrieren lediglich die Schätzproblematik, die auch bei diesem Verfahren besteht und die gerade beim Index Tracking mit wenigen Assets (so wie in dieser Fallstudie) besonders in Erscheinung tritt. Je mehr Assets für die Aufnahme in das Tracking Portfolio zur Verfügung stehen und je enger dieses an der Benchmark orientiert ist, umso geringer wird die Bedeutung der Schätzproblematik.</p>
</section>
<section id="regression-unter-nebenbedingungen-1" class="level3" data-number="9.3.4">
<h3 data-number="9.3.4" class="anchored" data-anchor-id="regression-unter-nebenbedingungen-1"><span class="header-section-number">9.3.4</span> Regression unter Nebenbedingungen</h3>
<p>Die Zielfunktion besteht darin die Summe der quadrierten aktiven Renditen <span class="math inline">\(r^2_{At}\)</span> über die vergangenen <span class="math inline">\(T\)</span> Perioden zu minimieren, unter den üblichen Nebenbedingungen (Budgetrestriktion, Leerverkaufsverbot, Bestandsgrenzen).</p>
<p><span class="math display">\[ \quad ZF(w)=\Sigma^T_{t=1}r^2_{At}=\Sigma^T_{t=1}(r_{Bt}-(w_{P1}r_{1t}+w_{P2}r_{2t}+...+w_{PN}r_{Nt}))^2 \rightarrow \min_{w}!\ \]</span></p>
<p><strong>Zur Erinnerung:</strong> Der Vektor der aktiven Gewichte <span class="math inline">\(w_A\)</span> ist definiert als Differenz der Portfolio- und Benchmarkgewichte, d.h. <span class="math inline">\(w_A=w_P-w_B\)</span>.</p>
<div id="cell-39" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># target function: minimize 'sum of squared active returns'!</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>    </span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="kw">def</span> tracking_error3(w, bench_w):</span>
<span id="cb32-4"><a href="#cb32-4"></a>    active_weights <span class="op">=</span> np.asarray(np.matrix(w) <span class="op">-</span> bench_w)</span>
<span id="cb32-5"><a href="#cb32-5"></a>    squared_act_ret <span class="op">=</span> (ex_returns.multiply(active_weights).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))<span class="op">**</span><span class="dv">2</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>    sum_squares <span class="op">=</span> <span class="bu">sum</span>(squared_act_ret[:<span class="dv">60</span>])</span>
<span id="cb32-7"><a href="#cb32-7"></a>    <span class="cf">return</span> sum_squares</span>
<span id="cb32-8"><a href="#cb32-8"></a></span>
<span id="cb32-9"><a href="#cb32-9"></a>cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span>})</span>
<span id="cb32-10"><a href="#cb32-10"></a></span>
<span id="cb32-11"><a href="#cb32-11"></a>bound <span class="op">=</span> (<span class="fl">0.05</span>,<span class="fl">0.40</span>)</span>
<span id="cb32-12"><a href="#cb32-12"></a>bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(alpha.shape[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb32-13"><a href="#cb32-13"></a>bounds <span class="op">+=</span> ((<span class="fl">0.0</span>, <span class="fl">1e-10</span>), ) <span class="co"># weight of the benchmark is fixed to zero</span></span>
<span id="cb32-14"><a href="#cb32-14"></a></span>
<span id="cb32-15"><a href="#cb32-15"></a>res3 <span class="op">=</span> minimize(tracking_error3, Weight_start, args<span class="op">=</span>bench_w,</span>
<span id="cb32-16"><a href="#cb32-16"></a>                method<span class="op">=</span><span class="st">'SLSQP'</span>, bounds<span class="op">=</span>bounds, </span>
<span id="cb32-17"><a href="#cb32-17"></a>                constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>, options<span class="op">=</span>{<span class="st">'disp'</span>: <span class="va">True</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.00761896940503493
            Iterations: 18
            Function evaluations: 217
            Gradient evaluations: 18</code></pre>
</div>
</div>
<div id="cell-40" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a>pd.DataFrame([<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res3.x], <span class="op">\</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>             index<span class="op">=</span>ex_returns.columns, columns<span class="op">=</span>[<span class="st">'Weight'</span>]).T</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="25">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">Weight</th>
<td>0.05</td>
<td>0.05</td>
<td>0.1175</td>
<td>0.148</td>
<td>0.05</td>
<td>0.0887</td>
<td>0.1127</td>
<td>0.1881</td>
<td>0.0516</td>
<td>0.1435</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="cell-41" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># tracking error</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>tracking_error2(res3.x, Sigma)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>0.00012866190903562024</code></pre>
</div>
</div>
<p>Auch hier ist ein Vergleich der Tracking Error im Schätz- und Validierungszeitraum aufschlussreich, um die Schätzproblematik zu illustrieren. Im Folgenden werden wieder die Werte für aktive Rendite und Tracking Error im Schätz- und Validierungszeitraum verglichen.</p>
<div id="cell-43" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a><span class="co"># calculation of realized TE and mean active return for </span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="co"># estimation and validation period</span></span>
<span id="cb37-3"><a href="#cb37-3"></a></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="co"># realized active return</span></span>
<span id="cb37-5"><a href="#cb37-5"></a>realized_act_ret <span class="op">=</span> ex_returns.multiply(res3.x).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)<span class="op">-</span>ex_returns[<span class="st">'EuroStoxx 50'</span>]</span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="co"># estimation period</span></span>
<span id="cb37-8"><a href="#cb37-8"></a>realized_eTE <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].var() <span class="co"># equals tracking_error2(res3.x, Sigma)</span></span>
<span id="cb37-9"><a href="#cb37-9"></a>realized_eAR <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].mean()</span>
<span id="cb37-10"><a href="#cb37-10"></a></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="co"># validation period</span></span>
<span id="cb37-12"><a href="#cb37-12"></a>realized_vTE <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].var() </span>
<span id="cb37-13"><a href="#cb37-13"></a>realized_vAR <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].mean() </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-44" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>realized_eTE</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>0.0001286619090356203</code></pre>
</div>
</div>
<div id="cell-45" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>realized_vTE</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>0.000391144336719732</code></pre>
</div>
</div>
<p>Ein Vergleich der Lösungen für das Tracking Portfolio nach dem Markowitz-Verfahren und der Regression unter Nebenbedingungen ist ebenfalls interessant. Die Gegenüberstellung der ermittelten, optimalen Anteilsgewichte zeigt nur geringfügige Abweichungen. Entsprechend fallen die Werte beider Tracking Portfolios für aktive Rendite und Tracking Error sowohl in Schätz- als auch Validierungszeitraum sehr ähnlich aus. Diese Ähnlichkeit ist aber nicht überraschend, denn die theoretische Analyse zeigte ja bereits, dass unter der Nebenbedingung einer erwarteten aktiven Rendite von null die Minimierung des ex ante Tracking Error (Markowitz-Verfahren) äquivalent zur (ex ante) Minimierung des Erwartungswertes der quadrierten aktiven Rendite ist. Insofern müssten eigentlich sogar dieselben Lösungen resultieren. Die Abweichungen erklären sich mit den unterschiedlichen Schätzverfahren, die bei beiden Ansätzen Verwendung finden.</p>
<p>Trotz der etwas aufwändigeren verfahrenstechnischen Umsetzung des Markowitz-Verfahrens ist dessen Vorteil die höhere Flexibilität, indem nämlich dort die Art der Schätzung der benötigten Inputparameter leicht gegen eine andere ausgetauscht werden kann, während bei diesem Verfahren letztendlich Optimierungsansatz und Schätzverfahren der benötigten Inputparameter untrennbar miteinander verbunden sind. Praktisch lässt sich aber der Vorteil des Markowitz-Verfahrens nur dann realisieren, wenn man wirklich über fortgeschrittenere Schätzverfahren als die hier exemplarisch verwendeten verfügt.</p>
</section>
<section id="lineare-optimierung-1" class="level3" data-number="9.3.5">
<h3 data-number="9.3.5" class="anchored" data-anchor-id="lineare-optimierung-1"><span class="header-section-number">9.3.5</span> Lineare Optimierung</h3>
<p>Bei der Bestimmung eines Tracking Portfolios mittels der linearen Optimierung ist die Besonderheit zu beachten, dass der Vektor der zu optimierenden Problemvariablen aus drei Komponenten besteht: 1) dem Vektor der Anteilsgewichte der Einzeltitel und dem (auf null fixiertem) Gewicht der Benchmark, 2) dem Vektor der negativen Restfehler <span class="math inline">\(d^-_t\)</span>, und 3) dem Vektor der positiven Restfehler <span class="math inline">\(d^+_t\)</span>. Im Rahmen der Fallstudie hat der erste Vektor die Dimension <span class="math inline">\(N=11\)</span> und die beiden anderen jeweils die Dimension <span class="math inline">\(T=60\)</span> (Länge des Schätzzeitraums).</p>
<p>Wir starten mit der Festlegung der Startlösung. Wie üblich verwenden wir ein naives (gleich gewichtetes) Portfolio für die Anteilsgewichte (das letzte Gewicht ist auf null festgelegt für das Target Portfolio/Benchmark).</p>
<div id="cell-48" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a><span class="co"># vector of starting weights is equally-weighted for the first N-1 </span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="co"># elements and zero for the last element</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>means <span class="op">=</span> ex_returns.iloc[:<span class="dv">60</span>,:].mean().values<span class="op">*</span><span class="dv">100</span><span class="op">*</span><span class="dv">12</span> <span class="co"># annualised?</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>Weight_start <span class="op">=</span> np.zeros(means.shape)</span>
<span id="cb42-5"><a href="#cb42-5"></a>Weight_start[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]<span class="op">=</span><span class="dv">1</span><span class="op">/</span>(means.shape[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Für die Restfehler werden jeweils Startwerte von null verwendet.</p>
<div id="cell-50" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>D_minus <span class="op">=</span> np.zeros(ex_returns[:<span class="dv">60</span>].shape[<span class="dv">0</span>])</span>
<span id="cb43-2"><a href="#cb43-2"></a>D_plus <span class="op">=</span> np.zeros(ex_returns[:<span class="dv">60</span>].shape[<span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Dann “verketten” wir die drei Arrays zum <span class="math inline">\((N+2T)\)</span>-Array der Startwerte, welches wir <code>params0</code> nennen.</p>
<div id="cell-52" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># starting values</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>params0 <span class="op">=</span> np.concatenate([Weight_start, D_minus, D_plus])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die zu minimierende Zielfunktion besteht in der Summe aller negativen Restfehler <span class="math inline">\(d^-_t\)</span>. Diese Funktion wird mit <code>tracking_error4</code> bezeichnet.</p>
<p>Beachten Sie, dass gemäß der obigen Definition im Array der Problemvariablen die negativen Restfehler an der Stelle <code>[11:71]</code> stehen.</p>
<div id="cell-54" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">def</span> tracking_error4(params):</span>
<span id="cb45-2"><a href="#cb45-2"></a>    sum_d_minus <span class="op">=</span>np.<span class="bu">sum</span>(params[<span class="dv">11</span>:<span class="dv">71</span>])</span>
<span id="cb45-3"><a href="#cb45-3"></a>    <span class="cf">return</span> sum_d_minus</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die verfahrenstechnische Schwierigkeit dieses Ansatzes besteht in der Implementierung der zentralen Nebenbedingung:</p>
<p><span class="math display">\[ \quad (\Sigma^N_{i=1} w_{Pi}r_{it}-d^+_t+d^-_t)-r_{Bt}=0 \qquad \text{für alle Zeitpunkte} \space t=1, ..., T. \]</span></p>
<p>Gemäß dieser Nebenbedingung muss für alle 60 Zeitpunkte <span class="math inline">\(t\)</span> die Rendite des Tracking Portfolios abzüglich des positiven Restfehlers <span class="math inline">\(d^+_t\)</span> und zuzüglich des negativen Restfehlers <span class="math inline">\(d^-_t\)</span> derjenigen des Index entsprechen. Im Kern handelt es sich hier also um ein System von <span class="math inline">\(T=60\)</span> strukturidentischen Nebenbedingungen.</p>
<p>Für ein beliebiges <span class="math inline">\(t=1, ..., 60\)</span> hat eine einzelne Nebenbedingung diese Struktur:</p>
<div id="cell-56" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a><span class="co"># structure of constraint for a given t=1, ..., 60</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>ex_returns.iloc[t, :].multiply(params[:<span class="dv">11</span>]).<span class="bu">sum</span>()<span class="op">\</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>                <span class="op">-</span> params[<span class="dv">71</span><span class="op">+</span>t] <span class="op">+</span> params[<span class="dv">11</span><span class="op">+</span>t] <span class="op">-</span> ex_returns[<span class="st">'EuroStoxx 50'</span>][t]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Wir implementieren dieses System von strukturidentischen Nebenbedingungen über die Funktion <code>constraint_maker</code>. Beachten Sie, dass für <code>i=60</code> diese Funktion die (gleich null gesetzte) Budgetrestriktion liefert.</p>
<div id="cell-58" class="cell" data-execution_count="34">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># definition of constraints</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">def</span> constraint_maker(i<span class="op">=</span><span class="dv">0</span>):  <span class="co"># i MUST be an optional keyword argument, else it will not work</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>    <span class="kw">def</span> constraint(params):</span>
<span id="cb47-4"><a href="#cb47-4"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">60</span>:</span>
<span id="cb47-5"><a href="#cb47-5"></a>            <span class="cf">return</span>  ex_returns.iloc[i, :].multiply(params[:<span class="dv">11</span>]).<span class="bu">sum</span>()<span class="op">\</span></span>
<span id="cb47-6"><a href="#cb47-6"></a>                <span class="op">-</span> params[<span class="dv">71</span><span class="op">+</span>i] <span class="op">+</span> params[<span class="dv">11</span><span class="op">+</span>i] <span class="op">-</span> ex_returns[<span class="st">'EuroStoxx 50'</span>][i]</span>
<span id="cb47-7"><a href="#cb47-7"></a>        <span class="cf">else</span>:</span>
<span id="cb47-8"><a href="#cb47-8"></a>            <span class="cf">return</span> np.<span class="bu">sum</span>(params[:<span class="dv">11</span>]) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb47-9"><a href="#cb47-9"></a>    <span class="cf">return</span> constraint</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Jetzt schreiben wir alle 60 Nebenbedingungen plus die Budgetrestriktion in Form des bekannten Tuples von Dictionaries der Form <code>{'type': 'eq', 'fun': constraint}</code>. Wir starten mit einer leeren List <code>c</code>. Diese füllen wir indem über eine for-Schleife die <code>constraint_maker</code> Funktion für <span class="math inline">\(i=1, ..., 61\)</span> ausgeführt wird und die Ergebnisse (zusammen mit dem Ausdruck <code>'type': 'eq', 'fun'</code>) jeweils der leeren Liste hinzugefügt werden. Abschließend wird die Liste in ein Tuple-Okjekt <code>cons</code> transformiert.</p>
<div id="cell-60" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a><span class="co"># making tuple with constraint dictionaries</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>c<span class="op">=</span>[]</span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">61</span>):</span>
<span id="cb48-4"><a href="#cb48-4"></a>    c<span class="op">+=</span>[{<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: constraint_maker(i)}]</span>
<span id="cb48-5"><a href="#cb48-5"></a>cons<span class="op">=</span><span class="bu">tuple</span>(c)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die weiteren Nebenbedingungen, dass die Restfehler nicht negativ werden dürfen, implementieren wird analog zum Leerverkaufsverbot bzw. den Bestandsgrenzen für die Anteilsgewichte über das Tuple <code>bounds</code>, das nun aus 131 Elementen, die selbst jeweils wieder Tuple darstellen, besteht.</p>
<p>Nun sind wir bereit für die eigentliche Optimierung!</p>
<div id="cell-62" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a><span class="co"># setting value constraints for optimizing parameters</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>bound <span class="op">=</span> (<span class="fl">0.05</span>,<span class="fl">0.40</span>) <span class="co"># bounds for portfolio weights</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(means.shape[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb49-4"><a href="#cb49-4"></a>bounds <span class="op">+=</span> ((<span class="fl">0.0</span>, <span class="fl">1e-10</span>), ) <span class="co"># weight of the benchmark is fixed to zero</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>bounds <span class="op">+=</span> ((<span class="fl">0.0</span>, <span class="fl">0.80</span>), )<span class="op">*</span><span class="dv">120</span> <span class="co"># bounds for D_minus and D_plus</span></span>
<span id="cb49-6"><a href="#cb49-6"></a></span>
<span id="cb49-7"><a href="#cb49-7"></a>res4 <span class="op">=</span> minimize(tracking_error4, params0,</span>
<span id="cb49-8"><a href="#cb49-8"></a>                method<span class="op">=</span><span class="st">'SLSQP'</span>, bounds<span class="op">=</span>bounds,</span>
<span id="cb49-9"><a href="#cb49-9"></a>                constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>, options<span class="op">=</span>{<span class="st">'disp'</span>: <span class="va">True</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.22318419504788067
            Iterations: 5
            Function evaluations: 660
            Gradient evaluations: 5</code></pre>
</div>
</div>
<div id="cell-63" class="cell" data-execution_count="37">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>pd.DataFrame([<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res4.x[:<span class="dv">11</span>]], <span class="op">\</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>             index<span class="op">=</span>ex_returns.columns, columns<span class="op">=</span>[<span class="st">'Weight'</span>]).T</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="37">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">Weight</th>
<td>0.0649</td>
<td>0.0889</td>
<td>0.1527</td>
<td>0.0561</td>
<td>0.05</td>
<td>0.05</td>
<td>0.1256</td>
<td>0.1853</td>
<td>0.05</td>
<td>0.1765</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Wie bei der theoretischen Analyse gezeigt, ist die Zielfunktion zur Ermittlung des Tracking Portfolios beim Markowitz-Ansatz und bei der Regression unter Nebenbedingungen weitgehend gleich, sodass unter gewissen Einschränkungen die Ergebnisse für beide Ansätz vergleichbar waren. Bei der linearen Optimierung zur Bestimmung des Tracking Portfolios wird dagegen eine völlig andere Zielfunktion optimiert. Insbesondere der klassische Tracking Error ist daher kein fairer Vergleichsmaßstab, denn er stellt im Wesentlichen die Zielfunktion der ersten beiden Verfahren dar, nicht aber diejenige bei diesem Ansatz. Hier ist die Zielfunktion die Minimierung der Summe aller Absolutbeträge der negativen Restfehler (Summe <span class="math inline">\(d^-\)</span>). Der Vollständigkeit halber wird er aber hier ausgewiesen.</p>
<div id="cell-65" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a><span class="co"># tracking error</span></span>
<span id="cb52-2"><a href="#cb52-2"></a>tracking_error2(res4.x[:<span class="dv">11</span>], Sigma)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>0.00014857682794648544</code></pre>
</div>
</div>
<p>Wurde das System der 60 strukturidentischen Nebenbedingungen eingehalten?</p>
<div id="cell-67" class="cell" data-execution_count="39">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># the main 60 constraints</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>ex_returns.iloc[:<span class="dv">60</span>, :].multiply(res4.x[<span class="dv">0</span>:<span class="dv">11</span>]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)<span class="op">\</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>        <span class="op">-</span> res4.x[<span class="dv">71</span>:<span class="dv">131</span>] <span class="op">+</span> res4.x[<span class="dv">11</span>:<span class="dv">71</span>] <span class="op">-</span> ex_returns[<span class="st">'EuroStoxx 50'</span>][:<span class="dv">60</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>2003-01-31    1.183900e-12
2003-02-28    2.049055e-14
2003-03-31   -6.702000e-13
2003-04-30   -9.861556e-14
2003-05-30    1.027078e-13
2003-06-30   -6.996764e-13
2003-07-31    6.922934e-14
2003-08-29    5.060015e-14
2003-09-30   -3.373968e-13
2003-10-31   -1.550690e-12
2003-11-28    1.321061e-13
2003-12-31   -3.337955e-13
2004-01-30    1.227837e-13
2004-02-27   -8.496676e-14
2004-03-31    4.060502e-13
2004-04-30    4.743220e-13
2004-05-31    1.754361e-13
2004-06-30   -4.130515e-13
2004-07-30    8.719622e-13
2004-08-31   -3.744574e-14
2004-09-30   -4.076114e-13
2004-10-29    2.583246e-13
2004-11-30   -9.510448e-14
2004-12-31   -2.037641e-13
2005-01-31   -1.333308e-14
2005-02-28    2.735798e-13
2005-03-31    5.278243e-14
2005-04-29   -3.917699e-14
2005-05-31   -8.158751e-14
2005-06-30    3.692879e-13
2005-07-29    3.459455e-13
2005-08-31    2.535472e-14
2005-09-30    2.005340e-13
2005-10-31   -1.994654e-13
2005-11-30    1.155673e-13
2005-12-30    3.311240e-13
2006-01-31   -8.300652e-14
2006-02-28    4.661202e-14
2006-03-31    8.990066e-13
2006-04-28   -9.701875e-14
2006-05-31   -8.119477e-13
2006-06-30   -1.821416e-14
2006-07-31   -5.789293e-14
2006-08-31    3.755676e-13
2006-09-29   -1.379487e-13
2006-10-31    8.963386e-13
2006-11-30    2.179160e-14
2006-12-29   -8.252427e-14
2007-01-31    3.724052e-13
2007-02-28   -1.203759e-13
2007-03-30   -1.878567e-13
2007-04-30   -4.330286e-13
2007-05-31    7.901735e-13
2007-06-29   -2.810842e-13
2007-07-31   -4.605621e-13
2007-08-31   -3.289036e-15
2007-09-28   -1.783400e-13
2007-10-31    5.477181e-13
2007-11-30   -3.118304e-13
2007-12-31   -2.353708e-13
dtype: float64</code></pre>
</div>
</div>
<div id="cell-68" class="cell" data-execution_count="40">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a><span class="co"># sum of D_plus</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="bu">sum</span>(res4.x[<span class="dv">71</span>:<span class="dv">131</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>0.3546793347396383</code></pre>
</div>
</div>
<div id="cell-69" class="cell" data-execution_count="41">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb58"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1"></a><span class="co"># sum of D_minus</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="bu">sum</span>(res4.x[<span class="dv">11</span>:<span class="dv">71</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>0.22318419504788067</code></pre>
</div>
</div>
<p>Nachfolgend stellen wir die Gütemaße für das Tracking Portfolio im Schätz- und Validierungszeitraum zusammen.</p>
<div id="cell-71" class="cell" data-execution_count="42">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a><span class="co"># calculation of realized TE and mean active return for </span></span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="co"># estimation and validation period</span></span>
<span id="cb60-3"><a href="#cb60-3"></a></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="co"># realized active return</span></span>
<span id="cb60-5"><a href="#cb60-5"></a>realized_act_ret <span class="op">=</span> ex_returns.multiply(res4.x[:<span class="dv">11</span>]).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)<span class="op">-</span>ex_returns[<span class="st">'EuroStoxx 50'</span>]</span>
<span id="cb60-6"><a href="#cb60-6"></a></span>
<span id="cb60-7"><a href="#cb60-7"></a><span class="co"># estimation period</span></span>
<span id="cb60-8"><a href="#cb60-8"></a>realized_eTE <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].var() <span class="co"># equals tracking_error2(res2.x, Sigma)</span></span>
<span id="cb60-9"><a href="#cb60-9"></a>realized_eAR <span class="op">=</span> realized_act_ret.iloc[:<span class="dv">60</span>].mean()</span>
<span id="cb60-10"><a href="#cb60-10"></a></span>
<span id="cb60-11"><a href="#cb60-11"></a><span class="co"># validation period</span></span>
<span id="cb60-12"><a href="#cb60-12"></a>realized_vTE <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].var() </span>
<span id="cb60-13"><a href="#cb60-13"></a>realized_vAR <span class="op">=</span> realized_act_ret.iloc[<span class="dv">60</span>:].mean() </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-72" class="cell" data-execution_count="43">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a>realized_eTE <span class="co"># estimation period</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>0.00014857682794648528</code></pre>
</div>
</div>
<div id="cell-73" class="cell" data-execution_count="44">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a>realized_vTE <span class="co"># validation period</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre><code>0.0003251365659092278</code></pre>
</div>
</div>
<div id="cell-74" class="cell" data-execution_count="45">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a>realized_eAR</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>0.0021915856615420536</code></pre>
</div>
</div>
<div id="cell-75" class="cell" data-execution_count="46">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb67"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1"></a>realized_vAR</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>0.006282117292094598</code></pre>
</div>
</div>
</section>
<section id="vergleich-der-ansätze" class="level3" data-number="9.3.6">
<h3 data-number="9.3.6" class="anchored" data-anchor-id="vergleich-der-ansätze"><span class="header-section-number">9.3.6</span> Vergleich der Ansätze</h3>
<div id="cell-77" class="cell" data-execution_count="47">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb69"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a>pd.DataFrame({<span class="st">'Relative Opt.'</span> :[<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res1.x], </span>
<span id="cb69-2"><a href="#cb69-2"></a>             <span class="st">'Markowitz'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res2.x],</span>
<span id="cb69-3"><a href="#cb69-3"></a>              <span class="st">'Linear Reg.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res3.x],</span>
<span id="cb69-4"><a href="#cb69-4"></a>              <span class="st">'Linear Opt.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res4.x[:<span class="dv">11</span>]]},</span>
<span id="cb69-5"><a href="#cb69-5"></a>          index<span class="op">=</span>ex_returns.columns)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="47">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Relative Opt.</th>
<th data-quarto-table-cell-role="th">Markowitz</th>
<th data-quarto-table-cell-role="th">Linear Reg.</th>
<th data-quarto-table-cell-role="th">Linear Opt.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">Danone</th>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0649</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Siemens</th>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0889</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BASF</th>
<td>0.0915</td>
<td>0.0902</td>
<td>0.1175</td>
<td>0.1527</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">L'Oreal</th>
<td>0.1587</td>
<td>0.1620</td>
<td>0.1480</td>
<td>0.0561</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Allianz</th>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0500</td>
<td>0.0500</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<td>0.1203</td>
<td>0.1178</td>
<td>0.0887</td>
<td>0.0500</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Banco Santander</th>
<td>0.0987</td>
<td>0.1001</td>
<td>0.1127</td>
<td>0.1256</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Total</th>
<td>0.1969</td>
<td>0.1916</td>
<td>0.1881</td>
<td>0.1853</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BMW</th>
<td>0.0585</td>
<td>0.0627</td>
<td>0.0516</td>
<td>0.0500</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Vivendi</th>
<td>0.1254</td>
<td>0.1257</td>
<td>0.1435</td>
<td>0.1765</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">EuroStoxx 50</th>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
<td>0.0000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Obwohl streng genommen ein Vergleich des Tracking Portfolios nach dem Ansatz der linearen Optimierung mit denjenigen der vorhergehenden Ansätze nicht zulässig ist, fallen schlussendlich die Ergebnisse nicht weit auseinander. Die resultierenden Strukturen der Tracking Portfolios sind in gewissen Grenzen doch sehr ähnlich, weshalb auch die Gütemaße im Validierungszeitraum nicht dramatisch voneinander abweichen. Die Erklärung für diese vielleicht etwas überraschende Ähnlichkeit ist aber nicht weiter schwierig. Die beiden vorhergehenden Ansätze (Markowitz-Ansatz, Regression unter Nebenbedingungen) basieren im Grunde auf einer Minimierung des quadratischen Fehlers (aktive Rendite) zwischen der Rendite des Tracking Portfolios und der Benchmark. Die lineare Optimierung minimiert die Summe der (Absolutbeträge der) negativen Fehler. Wenn nun im Schätzzeitraum die beobachteten Renditefehler annähernd symmetrisch um den Nullpunkt verteilt sind und keine gravierenden Ausreißer auftreten, ist die Zielfunktion nach der linearen Optimierung nur in etwa (abgesehen von der Quadrierung der Fehlerterme) anders skaliert als diejenige der ersten beiden Ansätze, was aber dann kaum Auswirkungen auf die Lage des Optimums hat. In diesem Fall resultieren in allen drei Fällen recht ähnliche Strukturen für das Tracking Portfolio.</p>
<div id="cell-79" class="cell" data-execution_count="48">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb70"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a><span class="im">from</span> matplotlib.pyplot <span class="im">import</span> <span class="op">*</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>fig, ax <span class="op">=</span> subplots()</span>
<span id="cb70-3"><a href="#cb70-3"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'Relative Opt.'</span> :[<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res1.x], </span>
<span id="cb70-4"><a href="#cb70-4"></a>             <span class="st">'Markowitz'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res2.x],</span>
<span id="cb70-5"><a href="#cb70-5"></a>              <span class="st">'Linear Reg.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res3.x],</span>
<span id="cb70-6"><a href="#cb70-6"></a>              <span class="st">'Linear Opt.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res4.x[:<span class="dv">11</span>]]},</span>
<span id="cb70-7"><a href="#cb70-7"></a>          index<span class="op">=</span>ex_returns.columns).T</span>
<span id="cb70-8"><a href="#cb70-8"></a>df.plot(kind<span class="op">=</span><span class="st">'bar'</span>,stacked<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))</span>
<span id="cb70-9"><a href="#cb70-9"></a>ax.legend(loc<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel8_files/figure-html/cell-48-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-80" class="cell" data-execution_count="49">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1"></a>pd.DataFrame({<span class="st">'Relative Opt.'</span> :[<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res1.x], </span>
<span id="cb71-2"><a href="#cb71-2"></a>             <span class="st">'Markowitz'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res2.x],</span>
<span id="cb71-3"><a href="#cb71-3"></a>              <span class="st">'Linear Reg.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res3.x],</span>
<span id="cb71-4"><a href="#cb71-4"></a>              <span class="st">'Linear Opt.'</span> : [<span class="bu">round</span>(x,<span class="dv">4</span>) <span class="cf">for</span> x <span class="kw">in</span> res4.x[:<span class="dv">11</span>]]},</span>
<span id="cb71-5"><a href="#cb71-5"></a>          index<span class="op">=</span>ex_returns.columns).T.plot.barh(stacked<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb71-6"><a href="#cb71-6"></a>                                                alpha<span class="op">=</span><span class="fl">.6</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">5</span>))<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel8_files/figure-html/cell-49-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./kapitel7.html" class="pagination-link" aria-label="Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./projekt.html" class="pagination-link" aria-label="Abschlußprojekt">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Abschlußprojekt</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>