<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; Berücksichtigung des Schätzrisikos: Portfolio-Resampling – Grundlagen des quantitativen Portfoliomanagements mit Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./kapitel7.html" rel="next">
<link href="./kapitel5.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e0fdce12ac1367d4b47c179a2935dd10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-74c88ba48ad0bebf983f0ffd06dd1671.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-e0fdce12ac1367d4b47c179a2935dd10.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./kapitel6.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Berücksichtigung des Schätzrisikos: Portfolio-Resampling</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Grundlagen des quantitativen Portfoliomanagements mit Python</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Willkommen zu „Grundlagen des quantitativen Portfoliomanagements mit Python“</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Grundlagen der klassischen (absoluten) Portfoliooptimierung</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Relative Portfoliooptimierung</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Schätzrisiken in der Portfoliotheorie</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Verbesserte Schätzung der Inputparameter: Geschrumpfte Schätzer</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Das Black-Litterman Modell</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel6.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Berücksichtigung des Schätzrisikos: Portfolio-Resampling</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./kapitel8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Index Tracking</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./projekt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Abschlußprojekt</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#grundlagen" id="toc-grundlagen" class="nav-link active" data-scroll-target="#grundlagen"><span class="header-section-number">7.1</span> Grundlagen</a></li>
  <li><a href="#beginn-der-fallstudie" id="toc-beginn-der-fallstudie" class="nav-link" data-scroll-target="#beginn-der-fallstudie"><span class="header-section-number">7.2</span> Beginn der Fallstudie</a>
  <ul class="collapse">
  <li><a href="#laden-und-beschreiben-der-datenbasis" id="toc-laden-und-beschreiben-der-datenbasis" class="nav-link" data-scroll-target="#laden-und-beschreiben-der-datenbasis"><span class="header-section-number">7.2.1</span> Laden und Beschreiben der Datenbasis</a></li>
  <li><a href="#portfoliooptimierung-mit-leerverkaufsverbot" id="toc-portfoliooptimierung-mit-leerverkaufsverbot" class="nav-link" data-scroll-target="#portfoliooptimierung-mit-leerverkaufsverbot"><span class="header-section-number">7.2.2</span> Portfoliooptimierung mit Leerverkaufsverbot</a></li>
  <li><a href="#exkurs-vergleich-simulierter-vs.-historischer-mittelwerte-und-varianzenkovarianzen" id="toc-exkurs-vergleich-simulierter-vs.-historischer-mittelwerte-und-varianzenkovarianzen" class="nav-link" data-scroll-target="#exkurs-vergleich-simulierter-vs.-historischer-mittelwerte-und-varianzenkovarianzen"><span class="header-section-number">7.2.3</span> Exkurs: Vergleich simulierter vs.&nbsp;historischer Mittelwerte und Varianzen/Kovarianzen</a></li>
  <li><a href="#graphische-darstellung-der-historischen-und-der-m-simulierten-effizienzkurven" id="toc-graphische-darstellung-der-historischen-und-der-m-simulierten-effizienzkurven" class="nav-link" data-scroll-target="#graphische-darstellung-der-historischen-und-der-m-simulierten-effizienzkurven"><span class="header-section-number">7.2.4</span> Graphische Darstellung der historischen und der <span class="math inline">\(M\)</span> simulierten Effizienzkurven</a></li>
  </ul></li>
  <li><a href="#literatur" id="toc-literatur" class="nav-link" data-scroll-target="#literatur"><span class="header-section-number">7.3</span> Literatur</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Berücksichtigung des Schätzrisikos: Portfolio-Resampling</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="grundlagen" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="grundlagen"><span class="header-section-number">7.1</span> Grundlagen</h2>
<p>Die Motivation der Resampling-Methode beruht auf der Erkenntnis, dass jede ermittelte Effizienzkurve mit Unsicherheit behaftet ist. Die Effizienzkurve wird auf Basis der Eingangsparameter (<span class="math inline">\(\mu\)</span> und <span class="math inline">\(\Sigma\)</span>) berechnet. Da die wahren Werte dieser Parameter ex ante unbekannt sind und nur geschätzt werden können, ist die wahre Effizienzkurve auch unbekannt und die ermittelte Kurve ist lediglich ein unsicherer Schätzer der wahren Effizienzkurve. Unsicherheit in den Eingangsparametern führt also zu Unsicherheit in der ermittelten Effizienzkurve.</p>
<p>Wie kann die Unsicherheit (das Schätzrisiko) in der Effizienzkurve quantifiziert werden? Und kann dadurch ein neuer Schätzer konstruiert werden, der dass Schätzrisiko reduziert (und damit stabilere Portfoliogewichte erzeugt, die weniger sensitiv auf Veränderungen der Eingabeparameter - dem Schätzrisiko in <span class="math inline">\(\mu\)</span> und <span class="math inline">\(\Sigma\)</span> - reagieren)? Die Resampling-Methode adressiert diese Fragen.</p>
<p>Die Methode gliedert sich grundsätzlich in die folgenden Schritte (vgl. ausführlicher Michaud und Michaud, 2008):</p>
<ul>
<li><p>Zunächst müssen die Eingabeparameter <span class="math inline">\(\mu\)</span> und <span class="math inline">\(\Sigma\)</span> geschätzt werden, z.B. auf Basis einer einfachen historischen Schätzung. Bezeichnen wir die Menge der geschätzten Parameter mit <span class="math inline">\(\theta\)</span>, und nehmen an, dass es <span class="math inline">\(m\)</span> Wertpapiere gibt.</p></li>
<li><p>Danach werden die Gewichte des Globalen Minimum Varianz Portfolios (MVP) und des Maximum Ertrags Portfolios (MEP) bestimmt. Wir bezeichnen die erwartete Rendite des MVP mit <span class="math inline">\(L\)</span>, und die des MEP mit <span class="math inline">\(H\)</span>.</p></li>
<li><p>Wir diskretisieren die stetige Effizienzkurve indem wir die Anzahl <span class="math inline">\(K\)</span> an erwarteten Renditen festlegen, für die wir die Effizienzkurve (das jeweils zur Zielrendite gehörende MVP) bestimmen wollen. Ist z.B. <span class="math inline">\(L=0,05\)</span> und <span class="math inline">\(H=0,20\)</span> und wir wählen eine Menge von <span class="math inline">\(K=16\)</span> Punkten, dann bestimmen wir die Effizienzkurve für die Zielrenditen <span class="math inline">\(\{0,05; 0,06; ...; 0,19; 0,20\}\)</span>. Dies ergibt <span class="math inline">\(16\)</span> unterschiedliche Punkte auf der Effizienzkurve.</p></li>
<li><p>Im Folgenden werden wir die diskretisierte Effizienzkurve in Form einer Matrix <span class="math inline">\(a_K\)</span> schreiben. Jedes Element der Matrix stellt dabei ein Portfoliogewicht dar. Die Matrix hat somit die Dimension <span class="math inline">\(Kxm\)</span> (die Zeilen repräsentieren die Zielrenditen, und die Spalten die Wertpapiere). Das Paar <span class="math inline">\((a_K, \theta)\)</span> beschreibt folglich die Effizienzkurve ermittelt auf Basis der (z.B. historisch) geschätzten Parameter. In unserem Beispiel gibt es 16 Zeilen (Zielrenditen, gleichmäßig verteilt zwischen <span class="math inline">\(L\)</span> und <span class="math inline">\(H\)</span>).</p></li>
<li><p>Wir beginnen mit der <strong>Monte Carlo Simulation</strong> indem wir eine Realisation <span class="math inline">\(\theta_i\)</span> aus der Wahrscheinlichkeitsverteilung von <span class="math inline">\(\theta\)</span> ziehen. <span class="math inline">\(\theta_i\)</span> und <span class="math inline">\(\theta\)</span> nennt man “statistisch äquivalent”. Dies beinhaltet die folgenden Schritte: Nehmen wir z.B. an unser Anlageuniversum besteht aus <span class="math inline">\(m=5\)</span> Wertpapieren und unsere historische Renditezeitreihe hat eine Länge von <span class="math inline">\(k=200\)</span> Beobachtungen. Wir verwenden einen Zufallszahlengenerator, <span class="math inline">\(\theta\)</span> (d.h., den historisch geschätzten Vektor der erwarteten Renditen <span class="math inline">\(\mu\)</span> und die historische Varianz-Kovarianzmatrix <span class="math inline">\(\Sigma\)</span>), unterstellen eine multivariate Normalverteilung für den Zufallsvektor <span class="math inline">\(R_m\)</span> der <span class="math inline">\(m\)</span> Renditen (d.h., <span class="math inline">\(R_m \sim N_m(\mu,\Sigma)\)</span>), und ziehen 200 Mal jeweils fünf Renditen (d.h., eine Realisation von <span class="math inline">\(R_m\)</span>) aus der unterstellten multivariaten Verteilung (muss nicht notwendigerweise die Normalverteilung sein). Auf Basis der simulierten Renditezeitreihen berechnen wir die simulierten <span class="math inline">\(\mu_i\)</span> und <span class="math inline">\(\Sigma_i\)</span>, d.h. <span class="math inline">\(\theta_i\)</span>.</p></li>
<li><p>Auf Basis von <span class="math inline">\(\theta_i\)</span>, Neuberechnung des MVP (erwartete Rendite <span class="math inline">\(L_i\)</span>) und des MEP (erwartete Rendite <span class="math inline">\(H_i\)</span>). Aufteilung des Intervals <span class="math inline">\([L_i,H_i]\)</span> in <span class="math inline">\(K\)</span> gleichmäßig verteilte Zielrenditen. In Anlehnung an das obige Beispiel mit <span class="math inline">\(K=16\)</span>, für <span class="math inline">\(L_i=0,03\)</span> und <span class="math inline">\(H_i=0,25\)</span> ergeben sich die folgenden Zielrenditen: <span class="math inline">\(\{0,030; 0,044; 0,058; ...; 0,236; 0,250\}\)</span>.</p></li>
<li><p>Bestimmung der effizienten Portfoliogewichte für jeden der <span class="math inline">\(K\)</span> Punkte (Ermittlung der MVP Gewichte für eine Zielrendite von 0,030; 0,044; … usw.). Daraus resultiert eine neue <span class="math inline">\(K x m\)</span> Matrix <span class="math inline">\(a_{K,i}\)</span>.</p></li>
<li><p>Wiederholung der Simulationen, so dass wir 1,000 <span class="math inline">\(a_{K,i}\)</span>’s erhalten.</p></li>
<li><p>Durchschnittsbildung über die 1,000 <span class="math inline">\(a_{K,i}\)</span>’s. Für jeden der <span class="math inline">\(K\)</span> Punkte und <span class="math inline">\(m\)</span> Wertpapiere resultieren damit durchschnittliche Portfoliogewichte. <span class="math inline">\(a^*_{K}\)</span> bezeichnet die <span class="math inline">\(Kxm\)</span> Matrix dieser durchschnittlichen Gewichte.</p></li>
<li><p>Bestimmung der <strong>Resampled-Effizienzkurve</strong> durch Kombination der originalen Parameterschätzungen (z.B. historisch) <span class="math inline">\(\theta=\{\mu,\Sigma\}\)</span> mit den Durchschnittsgewichten <span class="math inline">\(a^*_{K}\)</span>.</p></li>
</ul>
<p>Im Rahmen der folgenden Fallstudie wird die Resampling-Methode beispielhaft veranschaulicht.</p>
</section>
<section id="beginn-der-fallstudie" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="beginn-der-fallstudie"><span class="header-section-number">7.2</span> Beginn der Fallstudie</h2>
<p>Wir starten mit dem Import der benötigten Pakete.</p>
<div id="cell-3" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> la</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<section id="laden-und-beschreiben-der-datenbasis" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="laden-und-beschreiben-der-datenbasis"><span class="header-section-number">7.2.1</span> Laden und Beschreiben der Datenbasis</h3>
<p>Der verwendete Datensatz enthält Kurshistorien der folgenden zehn Aktien: Danone, Siemens, BASF, L’Oreal, Allianz, Telecom Italia, Banco Santander, Total, BMW, Vivendi. Zudem ist als elfte Spalte die Indexhistorie des Euro Stoxx 50 im Datensatz enthalten (diese wird nicht benötigt).</p>
<p>Die Zeitreihen umfassen 111 Monatsschlusskurse (“Adjusted Close”) über den Zeitraum vom 31.12.2002 bis zum 29.2.2012.</p>
<div id="cell-5" class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># hier den Pfad zur Datei einfügen</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"># cd "..."</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-6" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># load stock returns</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"># sample of 10 European stocks</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>frame1 <span class="op">=</span> pd.read_excel(<span class="st">'Kapitel A3_4.xlsx'</span>, <span class="st">'Tabelle1'</span>, index_col<span class="op">=</span><span class="dv">0</span>, parse_dates<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>frame1.drop(<span class="st">'EuroStoxx 50'</span>, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="cell-7" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>frame1.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Danone</th>
<th data-quarto-table-cell-role="th">Siemens</th>
<th data-quarto-table-cell-role="th">BASF</th>
<th data-quarto-table-cell-role="th">L'Oreal</th>
<th data-quarto-table-cell-role="th">Allianz</th>
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<th data-quarto-table-cell-role="th">Banco Santander</th>
<th data-quarto-table-cell-role="th">Total</th>
<th data-quarto-table-cell-role="th">BMW</th>
<th data-quarto-table-cell-role="th">Vivendi</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">2002-12-31</th>
<td>30.2427</td>
<td>40.50</td>
<td>18.040</td>
<td>72.55</td>
<td>82.025</td>
<td>2.0558</td>
<td>5.8537</td>
<td>33.5794</td>
<td>28.92</td>
<td>15.39</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">2003-01-31</th>
<td>27.6478</td>
<td>38.15</td>
<td>17.260</td>
<td>64.30</td>
<td>66.860</td>
<td>2.0199</td>
<td>5.1466</td>
<td>30.9888</td>
<td>27.26</td>
<td>15.64</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2003-02-28</th>
<td>25.9021</td>
<td>36.78</td>
<td>16.910</td>
<td>59.90</td>
<td>60.137</td>
<td>1.8927</td>
<td>5.3256</td>
<td>30.2486</td>
<td>26.00</td>
<td>13.02</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">2003-03-31</th>
<td>27.2939</td>
<td>37.80</td>
<td>17.055</td>
<td>55.50</td>
<td>41.080</td>
<td>2.0074</td>
<td>5.2361</td>
<td>28.6202</td>
<td>25.44</td>
<td>12.18</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2003-04-30</th>
<td>29.9125</td>
<td>44.67</td>
<td>19.985</td>
<td>64.05</td>
<td>63.350</td>
<td>2.1609</td>
<td>6.3012</td>
<td>28.9903</td>
<td>29.87</td>
<td>14.60</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Auf Basis von stetigen (log) Renditen werden die historischen Mittelwerte und die Varianz-Kovarianzmatrix der Renditen berechnet.</p>
<div id="cell-9" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># calculation of returns, and historical means and Sigma</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co"># using log returns</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>returns <span class="op">=</span> np.log1p(frame1.pct_change().dropna())</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co"># historical means and covariances</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>means_hist <span class="op">=</span> returns.mean().values</span>
<span id="cb5-8"><a href="#cb5-8"></a>Sigma_hist <span class="op">=</span> returns.cov().values</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
<section id="portfoliooptimierung-mit-leerverkaufsverbot" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="portfoliooptimierung-mit-leerverkaufsverbot"><span class="header-section-number">7.2.2</span> Portfoliooptimierung mit Leerverkaufsverbot</h3>
<p>Im Folgenden betrachten wir ausschießlich den Fall der Portfoliooptimierung mit Leerverkaufsverbot (implementiert über positive Bestandsgrenzen). Die Portfoliogewichte können also nur numerisch bestimmt werden.</p>
<p>Wir beginnen mit der Definition der Zielfunktionen der Optimierung: <span class="math inline">\(\sigma_P^2 \rightarrow \min_{w}!\)</span> für das GMVP bzw. für das MEP: <span class="math inline">\(\mu_P \rightarrow \max_{w}!\)</span>. Die dritte Funktion berechnet die erwartete Portfoliorendite.</p>
<div id="cell-11" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># necessary functions for calculating the: GMVP, MRP, min and max target</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co"># returns</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co"># specification of target function for MRP:</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">def</span> calculate_negative_portfolio_ret(w,means):</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="co"># function that calculates negative of portfolio return</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    means <span class="op">=</span> np.matrix(means)</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="cf">return</span> <span class="op">-</span>(w<span class="op">*</span>means.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co"># specification of target function for GMVP:</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">def</span> calculate_portfolio_var(w,Sigma):</span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="co"># function that calculates portfolio risk</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="cf">return</span> (w<span class="op">*</span>Sigma<span class="op">*</span>w.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb6-16"><a href="#cb6-16"></a></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">def</span> calculate_portfolio_ret(w,means):</span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="co"># function that calculates portfolio return</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>    w <span class="op">=</span> np.matrix(w) <span class="co"># w is a row (not column!) vector</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    means <span class="op">=</span> np.matrix(means)</span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="cf">return</span> (w<span class="op">*</span>means.T)[<span class="dv">0</span>,<span class="dv">0</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Wir implementieren die Bestimmung der optimalen Portfoliogewichte elegant und kompakt über die Funktionen <code>gmvp</code> und <code>mrp</code>.</p>
<div id="cell-13" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># functions that return the optimal portfolio weights</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co"># 1. GMVP</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co"># positive weights only</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">def</span> gmvp(Sigma):</span>
<span id="cb7-5"><a href="#cb7-5"></a>    num_assets <span class="op">=</span> <span class="bu">len</span>(Sigma)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span>})</span>
<span id="cb7-7"><a href="#cb7-7"></a>    bound <span class="op">=</span> (<span class="fl">0.0</span>,<span class="fl">1.0</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a>    bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(num_assets))   </span>
<span id="cb7-9"><a href="#cb7-9"></a>    res<span class="op">=</span> minimize(calculate_portfolio_var, num_assets<span class="op">*</span>[<span class="fl">1.</span><span class="op">/</span>num_assets,],</span>
<span id="cb7-10"><a href="#cb7-10"></a>                args<span class="op">=</span>Sigma, bounds <span class="op">=</span> bounds, method<span class="op">=</span><span class="st">'SLSQP'</span>,</span>
<span id="cb7-11"><a href="#cb7-11"></a>                constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>)</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="cf">return</span> res.x</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="co"># 2. MRP</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co"># positive weights only</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">def</span> mrp(means):</span>
<span id="cb7-17"><a href="#cb7-17"></a>    num_assets <span class="op">=</span> <span class="bu">len</span>(means)</span>
<span id="cb7-18"><a href="#cb7-18"></a>    cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x: np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span>})</span>
<span id="cb7-19"><a href="#cb7-19"></a>    bound <span class="op">=</span> (<span class="fl">0.0</span>,<span class="fl">1.0</span>)</span>
<span id="cb7-20"><a href="#cb7-20"></a>    bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(num_assets))   </span>
<span id="cb7-21"><a href="#cb7-21"></a>    res<span class="op">=</span> minimize(calculate_negative_portfolio_ret, </span>
<span id="cb7-22"><a href="#cb7-22"></a>                  num_assets<span class="op">*</span>[<span class="fl">1.</span><span class="op">/</span>num_assets,],</span>
<span id="cb7-23"><a href="#cb7-23"></a>                  args<span class="op">=</span>means, bounds <span class="op">=</span> bounds, method<span class="op">=</span><span class="st">'SLSQP'</span>,</span>
<span id="cb7-24"><a href="#cb7-24"></a>                  constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>)</span>
<span id="cb7-25"><a href="#cb7-25"></a>    <span class="cf">return</span> res.x</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Wird dann die Portfoliooptimierung für <span class="math inline">\(K\)</span> verschiedene Zielrenditen zwischen der erwarteten Rendite des MVP (Objekt <code>min</code>) und der des MEP (Objekt <code>max</code>) durchgeführt, ergibt sich die entsprechende diskretisierte Effizienzkurve. Die Anzahl Punkte <span class="math inline">\(K\)</span> wird über das Argument <code>K</code> eingestellt.</p>
<div id="cell-15" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># calculation of efficient frontier, i.e. a (Kxm)-matrix of m stock </span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"># weights for K different target returns</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co"># efficient frontier with hist. mean returns</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">def</span> ef_front(means, Sigma, K<span class="op">=</span><span class="dv">30</span>):</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co"># calculation of min and max target return</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co"># min: expected return of GMVP, max: expected return of MRP</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="bu">min</span> <span class="op">=</span> calculate_portfolio_ret(gmvp(Sigma), means)</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="bu">max</span> <span class="op">=</span> calculate_portfolio_ret(mrp(means), means)</span>
<span id="cb8-10"><a href="#cb8-10"></a>    </span>
<span id="cb8-11"><a href="#cb8-11"></a>    V_Target <span class="op">=</span> np.linspace(<span class="bu">min</span>, <span class="bu">max</span>, num<span class="op">=</span>K) <span class="co"># use K=30 points of the ef!</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>    V_Risk <span class="op">=</span> np.zeros(V_Target.shape)</span>
<span id="cb8-13"><a href="#cb8-13"></a>    V_Weight <span class="op">=</span> np.zeros((V_Target.shape[<span class="dv">0</span>], means.shape[<span class="dv">0</span>]))</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="cf">for</span> idx, Target_Return <span class="kw">in</span> <span class="bu">enumerate</span>(V_Target):</span>
<span id="cb8-15"><a href="#cb8-15"></a>        num_assets <span class="op">=</span> <span class="bu">len</span>(means)</span>
<span id="cb8-16"><a href="#cb8-16"></a>        bound <span class="op">=</span> (<span class="fl">0.0</span>,<span class="fl">1.0</span>)</span>
<span id="cb8-17"><a href="#cb8-17"></a>        bounds <span class="op">=</span> <span class="bu">tuple</span>(bound <span class="cf">for</span> asset <span class="kw">in</span> <span class="bu">range</span>(num_assets)) </span>
<span id="cb8-18"><a href="#cb8-18"></a>        cons <span class="op">=</span> ({<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x:  np.<span class="bu">sum</span>(x)<span class="op">-</span><span class="fl">1.0</span>},</span>
<span id="cb8-19"><a href="#cb8-19"></a>                {<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: <span class="kw">lambda</span> x:  <span class="op">\</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>                 calculate_portfolio_ret(x,means)<span class="op">-</span>Target_Return})</span>
<span id="cb8-21"><a href="#cb8-21"></a>        res<span class="op">=</span> minimize(calculate_portfolio_var,num_assets<span class="op">*</span>[<span class="fl">1.</span><span class="op">/</span>num_assets,],</span>
<span id="cb8-22"><a href="#cb8-22"></a>                      args<span class="op">=</span>Sigma,bounds <span class="op">=</span> bounds, method<span class="op">=</span><span class="st">'SLSQP'</span>,</span>
<span id="cb8-23"><a href="#cb8-23"></a>                      constraints<span class="op">=</span>cons,tol<span class="op">=</span><span class="fl">1e-10</span>)</span>
<span id="cb8-24"><a href="#cb8-24"></a>        V_Weight[idx, :] <span class="op">=</span> res.x.T</span>
<span id="cb8-25"><a href="#cb8-25"></a>        V_Risk[idx] <span class="op">=</span> np.sqrt(calculate_portfolio_var(res.x, Sigma))</span>
<span id="cb8-26"><a href="#cb8-26"></a>    <span class="cf">return</span> V_Weight, V_Risk, V_Target</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die folgende Funktion <code>resampled_weights</code> implementiert die Monte Carlo Simulation. Es wird im Ergebnis die “Durchschnittsmatrix” <span class="math inline">\(a^*_K\)</span> der <span class="math inline">\(M\)</span> simulierten Portfoliogewichtsmatrizen <span class="math inline">\(a_{K,i}\)</span> zurückgegeben.</p>
<p>In jedem Simulationsschritt <span class="math inline">\(i=1, ..., M\)</span> werden zunächst über <code>random.multivariate_normal(Mu, Sigma, size=k)</code> <span class="math inline">\(k\)</span> Realisationen aus der angegebenen multivariaten Normalverteilung gezogen und in das DataFrame <code>df</code> überführt. Auf Basis dieser simulierten Daten berechnen sich <span class="math inline">\(\mu_i\)</span> und <span class="math inline">\(\Sigma_i\)</span>, die wiederum eingesetzt in die oben definierte Funktion <code>ef_front</code> die simulierte Effizienzkurve <span class="math inline">\(a_{K,i}\)</span> ergeben. Diese Gewichtsmatrix wird dann als zweidimensionales (2-D) Array (Matrix) der Liste <code>liste</code> hinzugefügt. Final werden die <span class="math inline">\(M\)</span> 2-D Arrays in der Liste gemittelt.</p>
<div id="cell-17" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> resampled_weights(M, means_hist, Sigma_hist):</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># M: number of Monte Carlo runs   </span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a>    liste <span class="op">=</span> []</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb9-6"><a href="#cb9-6"></a>        df <span class="op">=</span> pd.DataFrame(np.asarray(np.random.multivariate_normal(means_hist,<span class="op">\</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>                Sigma_hist, size <span class="op">=</span> <span class="dv">110</span>)), columns<span class="op">=</span>frame1.columns)</span>
<span id="cb9-8"><a href="#cb9-8"></a>        means <span class="op">=</span> df.mean().values</span>
<span id="cb9-9"><a href="#cb9-9"></a>        Sigma <span class="op">=</span> df.cov().values</span>
<span id="cb9-10"><a href="#cb9-10"></a>        weight, _, _ <span class="op">=</span> ef_front(means, Sigma)</span>
<span id="cb9-11"><a href="#cb9-11"></a>        <span class="co"># weight is the (Kxm) matrix for each i=1,..M simulation</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>        liste.append(weight) </span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="cf">return</span> np.average(liste, axis<span class="op">=</span><span class="dv">0</span>) </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die finale Funktion <code>sim_ef</code> berechnet die <strong>Resampled-Effizienzkurve</strong> durch Kombination der originalen (historischen) Parameterschätzungen <code>means_hist</code> und <code>Sigma_hist</code> mit den Durchschnittsgewichten <code>sim_weights</code> (<span class="math inline">\(a^*_{K}\)</span>).</p>
<p>Hierbei gibt <code>sim_weights.shape[0]</code> die Anzahl der Punkte <span class="math inline">\(K\)</span> (hier 30, Anzahl Zeilen der Gewichtsmatrix) der diskretisierten Effizienzkurve an.</p>
<p>Über eine for-Schleife werden zunächst das Portfoliorisiko <span class="math inline">\(\sigma^{2*}_P\)</span> und die erwartete Portfoliorendite <span class="math inline">\(\mu^*_P\)</span> für jeden der <span class="math inline">\(K=30\)</span> simulierten Durchschnittsgewichtsvektoren <span class="math inline">\(a^*_{k}\)</span> (mit <span class="math inline">\(k=1, ..., K\)</span>) berechnet und in den 1-D Arrays (Vektoren) <code>V-Risk</code> und <code>V_Return</code> gespeichert.</p>
<div id="cell-19" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># function for drawing the efficient frontier based on simulated</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># Kxm weight matrix</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"># efficient frontier on the basis of simulated weights </span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">def</span> sim_ef(M, means_hist, Sigma_hist):</span>
<span id="cb10-6"><a href="#cb10-6"></a>    sim_weights <span class="op">=</span> resampled_weights(M, means_hist, Sigma_hist)</span>
<span id="cb10-7"><a href="#cb10-7"></a>    V_Risk <span class="op">=</span> np.zeros(sim_weights.shape[<span class="dv">0</span>])</span>
<span id="cb10-8"><a href="#cb10-8"></a>    V_Return <span class="op">=</span> np.zeros(sim_weights.shape[<span class="dv">0</span>])</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(sim_weights.shape[<span class="dv">0</span>]):</span>
<span id="cb10-10"><a href="#cb10-10"></a>        V_Risk[i] <span class="op">=</span> np.sqrt(calculate_portfolio_var(sim_weights[i,:], Sigma_hist))</span>
<span id="cb10-11"><a href="#cb10-11"></a>        V_Return[i] <span class="op">=</span> calculate_portfolio_ret(sim_weights[i,:],means_hist)</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="cf">return</span> V_Risk, V_Return, sim_weights</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Wir rufen die oben definierten Funktionen für die simulierte (<code>sim_ef</code>) und die “klassische” (<code>ef_front</code>) Effizienzkurve nun auf. Die beiden <span class="math inline">\(Kxm\)</span> Gewichtsmatrizen werden in den 2-D Arrays <code>S_Weight</code> und <code>V_Weight</code> gespeichert. Portfoliorisiko und erwarte Rendite sind in entsprechend bezeichneten 1-D Arrays (Vektoren) enthalten: <code>S_Risk</code> (für <span class="math inline">\(\sigma^{2*}_P\)</span>), <code>S_Return</code> (für <span class="math inline">\(\mu^*_P\)</span>), <code>V_Risk</code> (für <span class="math inline">\(\sigma^2_P\)</span>) und <code>V_Target</code> (für <span class="math inline">\(\mu_P\)</span>).</p>
<div id="cell-21" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># simulated efficient frontier based on average simulated weights</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>S_Risk, S_Return, S_Weight <span class="op">=</span> sim_ef(<span class="dv">100</span>, means_hist, Sigma_hist)</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># classic efficient frontier based on historical data</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>V_Weight, V_Risk, V_Target <span class="op">=</span> ef_front(means_hist, Sigma_hist)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Nun plotten wir die beiden Effizienzkurven zusammen mit den Positionen der einzelnen zehn Wertpapiere.</p>
<div id="cell-23" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>fig1 <span class="op">=</span> plt.figure(num<span class="op">=</span><span class="dv">1</span>, facecolor<span class="op">=</span><span class="st">'w'</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb12-2"><a href="#cb12-2"></a>ax <span class="op">=</span> fig1.add_subplot(<span class="dv">111</span>)</span>
<span id="cb12-3"><a href="#cb12-3"></a>plt.plot(V_Risk, V_Target, <span class="st">'g:'</span>, label<span class="op">=</span><span class="st">'Historical frontier'</span>)</span>
<span id="cb12-4"><a href="#cb12-4"></a>plt.plot(S_Risk, S_Return, <span class="st">'g-'</span>, label<span class="op">=</span><span class="st">'Resampled frontier'</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a>plt.plot(np.sqrt(np.diagonal(Sigma_hist)), means_hist, <span class="st">'rx'</span>, label<span class="op">=</span><span class="st">'Asset'</span>)</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="cf">for</span> i, txt <span class="kw">in</span> <span class="bu">enumerate</span>(frame1.columns):</span>
<span id="cb12-7"><a href="#cb12-7"></a>   ax.annotate(txt, (np.sqrt(np.diagonal(Sigma_hist))[i],means_hist[i]))</span>
<span id="cb12-8"><a href="#cb12-8"></a>plt.legend(loc<span class="op">=</span><span class="dv">4</span>,  frameon<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-9"><a href="#cb12-9"></a>plt.xlabel(<span class="st">'Standard deviation'</span>)</span>
<span id="cb12-10"><a href="#cb12-10"></a>plt.ylabel(<span class="st">'Expected return'</span>)</span>
<span id="cb12-11"><a href="#cb12-11"></a>plt.title(<span class="st">'Comparison of efficient frontiers'</span>)</span>
<span id="cb12-12"><a href="#cb12-12"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel6_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Offensichtlich liegt die simulierte Effizienzkurve unterhalb der klassischen Effizienzkurve. Warum?</p>
<p>Wenn wir uns eine bestimmte Monte Carlo Ziehung ansehen, sagen wir <span class="math inline">\(\theta_i\)</span>, und die dazugehörige Kurve zeichnen, kann diese rechts oder links von der ursprünglichen Kurve liegen. Wir verfolgen die Portfoliogewichte an diskreten Punkten. Wir mitteln diese Gewichte (nicht die Kurven) - und wenden diese Durchschnittsgewichte dann auf das Original <span class="math inline">\(\theta\)</span> an.</p>
<p>Wir wissen, dass die optimalen (effizienten) Portfoliogewichte, gegeben <span class="math inline">\(\theta\)</span>, durch <span class="math inline">\(a_K\)</span> repräsentiert werden. Wenn wir <span class="math inline">\(a^*_K\)</span> auf <span class="math inline">\(\theta\)</span> anwenden muss folglich die resultierende Kurve rechts von der Originalkurve liegen. Mit anderen Worten, wenn <span class="math inline">\(a_K\)</span> effizient für <span class="math inline">\(\theta\)</span> ist, kann <span class="math inline">\(a^*_K\)</span> nicht auch effizient für <span class="math inline">\(\theta\)</span> sein. Jede einzelne simulierte Effizienzkurve ist zwar effizient gegenüber den jeweils dazugehörigen simulierten <span class="math inline">\(\mu_i\)</span> und <span class="math inline">\(\Sigma_i\)</span>, jedoch ineffizient gegenüber der ursprünglichen historischen Schätzung <span class="math inline">\(\mu\)</span> und <span class="math inline">\(\Sigma\)</span>. Ein auf der Grundlage des Portfolio-Resamplings ermitteltes Portfolio ist daher per Definition nicht mehr effizient für <span class="math inline">\(\theta\)</span>, es berücksichtigt aber das Schätzrisiko bezogen auf das wahre <span class="math inline">\(\theta\)</span>.</p>
<p>Wir plotten nun in Form eines Balkendiagramms die zu den Effizienzkurven gehörenden Portfoliogewichte:</p>
<ol type="1">
<li>Resampled-Effizienzkurve</li>
</ol>
<div id="cell-26" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>fig2 <span class="op">=</span> plt.figure(num<span class="op">=</span><span class="dv">2</span>, facecolor<span class="op">=</span><span class="st">'w'</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb13-2"><a href="#cb13-2"></a>plt.stackplot(S_Return<span class="op">*</span><span class="dv">12</span>, S_Weight.T<span class="op">*</span><span class="dv">100</span>) <span class="co"># annualised returns</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>plt.axis([np.<span class="bu">min</span>(S_Return<span class="op">*</span><span class="dv">12</span>), np.<span class="bu">max</span>(S_Return<span class="op">*</span><span class="dv">12</span>), <span class="fl">0.0</span>, <span class="fl">100.0</span>])</span>
<span id="cb13-4"><a href="#cb13-4"></a>plt.legend(<span class="bu">list</span>(frame1.columns),</span>
<span id="cb13-5"><a href="#cb13-5"></a>           loc<span class="op">=</span><span class="st">'upper left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">1.0</span>, <span class="fl">1.0</span>), frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-6"><a href="#cb13-6"></a>plt.xlabel(<span class="st">'Target expected return'</span>)</span>
<span id="cb13-7"><a href="#cb13-7"></a>plt.ylabel(<span class="st">'Allocation weight (%)'</span>)</span>
<span id="cb13-8"><a href="#cb13-8"></a>plt.title(<span class="st">'Portfolioweights for the resampled efficient frontier'</span>)</span>
<span id="cb13-9"><a href="#cb13-9"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel6_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ol start="2" type="1">
<li>Klassische Effizienzkurve auf Basis einfacher historisch basierter Schätzung</li>
</ol>
<div id="cell-28" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>fig3 <span class="op">=</span> plt.figure(num<span class="op">=</span><span class="dv">3</span>, facecolor<span class="op">=</span><span class="st">'w'</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb14-2"><a href="#cb14-2"></a>plt.stackplot(V_Target<span class="op">*</span><span class="dv">12</span>, V_Weight.T<span class="op">*</span><span class="dv">100</span>)</span>
<span id="cb14-3"><a href="#cb14-3"></a>plt.axis([np.<span class="bu">min</span>(V_Target<span class="op">*</span><span class="dv">12</span>), np.<span class="bu">max</span>(V_Target<span class="op">*</span><span class="dv">12</span>), <span class="fl">0.0</span>, <span class="fl">100.0</span>]) <span class="co"># annualised return</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>plt.legend(<span class="bu">list</span>(frame1.columns),</span>
<span id="cb14-5"><a href="#cb14-5"></a>           loc<span class="op">=</span><span class="st">'upper left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">1.0</span>, <span class="fl">1.0</span>), frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-6"><a href="#cb14-6"></a>plt.xlabel(<span class="st">'Target expected return'</span>)</span>
<span id="cb14-7"><a href="#cb14-7"></a>plt.ylabel(<span class="st">'Allocation weight (%)'</span>)</span>
<span id="cb14-8"><a href="#cb14-8"></a>plt.title(<span class="st">'Portfolioweights for the historic efficient frontier'</span>)</span>
<span id="cb14-9"><a href="#cb14-9"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel6_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Ein Vergleich der Diagramme zeigt, dass im Rahmen des Portfolio-Resamplings eindeutig eine höhere Anzahl an Wertpapieren in die Portfoliokonstruktion aufgenommen wird. Dadurch lässt sich eine höhere Diversifiktion der Portfolios erreichen. Zudem zeigen sich weniger plötzliche Verschiebungen in der Portfoliostruktur der einzelnen Wertpapiere. Die Portfoliozusammensetzung ist insgesamt diversifizierter und weniger volatil. Die stabilen Portfolioallokationen ergeben sich als Folge der Bildung durchschnittlicher Portfoliogewichte, so dass geringe Veränderungen in den Eingangsgrößen nunmehr lediglich zu geringen Veränderungen der optimierten Portfolios führen können.</p>
</section>
<section id="exkurs-vergleich-simulierter-vs.-historischer-mittelwerte-und-varianzenkovarianzen" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="exkurs-vergleich-simulierter-vs.-historischer-mittelwerte-und-varianzenkovarianzen"><span class="header-section-number">7.2.3</span> Exkurs: Vergleich simulierter vs.&nbsp;historischer Mittelwerte und Varianzen/Kovarianzen</h3>
<p>Wir simulieren eine (d.h., ziehen zufällige Realisationen aus einer) multivariaten Normalverteilung. Durch Erhöhung der Anzahl <code>size</code> an Ziehungen nähern sich die simulierten Momente den wahren Momenten <span class="math inline">\(\mu\)</span> und <span class="math inline">\(\Sigma\)</span> der Verteilung an.</p>
<div id="cell-31" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>np.random.seed(<span class="dv">32</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a>df <span class="op">=</span> pd.DataFrame(np.asarray(np.random.multivariate_normal(means_hist,<span class="op">\</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>                Sigma_hist, size <span class="op">=</span> <span class="dv">50000</span>)), columns<span class="op">=</span>frame1.columns)</span>
<span id="cb15-4"><a href="#cb15-4"></a>pd.DataFrame({<span class="st">'sim'</span>: df.mean().values, <span class="st">'hist.'</span>: means_hist,<span class="op">\</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>             <span class="st">'difference'</span>:df.mean().values<span class="op">-</span>means_hist}, <span class="op">\</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>             index<span class="op">=</span>frame1.columns)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sim</th>
<th data-quarto-table-cell-role="th">hist.</th>
<th data-quarto-table-cell-role="th">difference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">Danone</th>
<td>0.004407</td>
<td>0.004711</td>
<td>-0.000304</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Siemens</th>
<td>0.004495</td>
<td>0.005585</td>
<td>-0.001090</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BASF</th>
<td>0.010784</td>
<td>0.011778</td>
<td>-0.000994</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">L'Oreal</th>
<td>0.000882</td>
<td>0.001505</td>
<td>-0.000623</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Allianz</th>
<td>-0.000273</td>
<td>0.000947</td>
<td>-0.001220</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Telecom Italia</th>
<td>-0.007887</td>
<td>-0.007870</td>
<td>-0.000017</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Banco Santander</th>
<td>-0.000349</td>
<td>0.000191</td>
<td>-0.000540</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Total</th>
<td>0.001659</td>
<td>0.002032</td>
<td>-0.000373</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">BMW</th>
<td>0.006899</td>
<td>0.007962</td>
<td>-0.001063</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">Vivendi</th>
<td>-0.000316</td>
<td>0.000421</td>
<td>-0.000737</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="graphische-darstellung-der-historischen-und-der-m-simulierten-effizienzkurven" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="graphische-darstellung-der-historischen-und-der-m-simulierten-effizienzkurven"><span class="header-section-number">7.2.4</span> Graphische Darstellung der historischen und der <span class="math inline">\(M\)</span> simulierten Effizienzkurven</h3>
<p>Abschließend plotten wir die originale Effizienzkurve zusammen mit den <span class="math inline">\(M\)</span> simulierten Effizienzkurven.</p>
<p>Dazu generieren wir zwei Listen-Okjekte: <code>liste_Risk</code> für die Portfoliovarianz und <code>liste_Target</code> für die erwartete Portfoliorendite. Beide Listen sollen final <span class="math inline">\((1+M)\)</span> Elemente (jeweils 1-D Arrays der Dimension <span class="math inline">\(K\)</span>) enthalten. Jede Effizienzkurve besteht dabei aus <span class="math inline">\(K\)</span> Punkten.</p>
<p>Zunächst berechnen wir die historische Effizienzkurve über <code>ef_front</code> und weisen die 1-D (Dimension=K) Arrays <code>Risk</code> (für <span class="math inline">\(\sigma^2_P\)</span>) und <code>Target</code> (für <span class="math inline">\(\mu_P\)</span>) den beiden Listen zu. Danach simulieren wir für <span class="math inline">\(i=1,..., M\)</span> auf Basis der Annahme einer multivariaten Normalverteilung für den Renditevektor die Werte der Eingabeparameter <span class="math inline">\(\theta_i=\{\mu_i, \Sigma_i\}\)</span> und berechnen jeweils die <span class="math inline">\(M\)</span> Effizienzkurven. Die beiden Arrays mit den Charakteristiken der Effizienzkurven (<span class="math inline">\(\mu_{P,i}\)</span> und <span class="math inline">\(\sigma^2_{P,i}\)</span>) werden wiederum den Listen zugewiesen.</p>
<p>Abschließend werden beide Listen in Arrays (d.h. <span class="math inline">\((M+1)xK\)</span>)-Matrizen transformiert und von der Funktion zurückgegeben.</p>
<div id="cell-33" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># function returns two lists with (1+M) elements; </span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co"># each element is a 1-D array of dimension K;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co"># K is the number of points on the ef: K different target </span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co"># expected portfolio returns and portfolio return std's</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">def</span> resampled_frontiers(M, means_hist, Sigma_hist):</span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co"># M: number of Monte Carlo runs   </span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb16-8"><a href="#cb16-8"></a>    liste_Risk <span class="op">=</span> []</span>
<span id="cb16-9"><a href="#cb16-9"></a>    liste_Target <span class="op">=</span> []</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="co"># first, calculate the historical ef </span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    _, Risk, Target <span class="op">=</span> ef_front(means_hist, Sigma_hist)</span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="co"># and append to the two lists</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>    liste_Risk.append(Risk)</span>
<span id="cb16-14"><a href="#cb16-14"></a>    liste_Target.append(Target)</span>
<span id="cb16-15"><a href="#cb16-15"></a>    <span class="co"># now, calculate the M simulated ef's</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb16-17"><a href="#cb16-17"></a>        df <span class="op">=</span> pd.DataFrame(np.asarray(np.random.multivariate_normal(means_hist,<span class="op">\</span></span>
<span id="cb16-18"><a href="#cb16-18"></a>                Sigma_hist, size <span class="op">=</span> <span class="dv">110</span>)), columns<span class="op">=</span>frame1.columns)</span>
<span id="cb16-19"><a href="#cb16-19"></a>        means <span class="op">=</span> df.mean().values</span>
<span id="cb16-20"><a href="#cb16-20"></a>        Sigma <span class="op">=</span> df.cov().values</span>
<span id="cb16-21"><a href="#cb16-21"></a>        <span class="co"># ef_front returns: weights, risk, target return! </span></span>
<span id="cb16-22"><a href="#cb16-22"></a>        _, Risk, Target <span class="op">=</span> ef_front(means, Sigma)</span>
<span id="cb16-23"><a href="#cb16-23"></a>        <span class="co"># and append to the lists</span></span>
<span id="cb16-24"><a href="#cb16-24"></a>        liste_Risk.append(Risk)</span>
<span id="cb16-25"><a href="#cb16-25"></a>        liste_Target.append(Target)</span>
<span id="cb16-26"><a href="#cb16-26"></a>    liste_Risk <span class="op">=</span> np.array(liste_Risk)</span>
<span id="cb16-27"><a href="#cb16-27"></a>    liste_Target <span class="op">=</span> np.array(liste_Target)</span>
<span id="cb16-28"><a href="#cb16-28"></a>    <span class="cf">return</span> liste_Risk, liste_Target </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Die folgende Funktion <code>draw_efs</code> zeichnet nun die historische zusammen mit den <span class="math inline">\(M\)</span> simulierten Effizienzkurven. Hierfür werden die beiden Arrays der Funktion <code>resampled_frontiers</code> verwendet.</p>
<div id="cell-35" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">def</span> draw_efs(M, means_hist, Sigma_hist):</span>
<span id="cb17-2"><a href="#cb17-2"></a>    Risk, Target <span class="op">=</span> resampled_frontiers(M, means_hist, Sigma_hist)</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a>    fig1 <span class="op">=</span> plt.figure(num<span class="op">=</span><span class="dv">1</span>, facecolor<span class="op">=</span><span class="st">'w'</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb17-5"><a href="#cb17-5"></a>    ax <span class="op">=</span> fig1.add_subplot(<span class="dv">111</span>)</span>
<span id="cb17-6"><a href="#cb17-6"></a>    plt.plot(Risk[<span class="dv">0</span>,:], Target[<span class="dv">0</span>,:], <span class="st">'g:'</span>, label<span class="op">=</span><span class="st">'Historical frontier'</span>)</span>
<span id="cb17-7"><a href="#cb17-7"></a>    plt.plot(Risk[<span class="dv">1</span>,:], Target[<span class="dv">1</span>,:], <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'Resampled frontiers'</span>)</span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,M<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb17-9"><a href="#cb17-9"></a>        plt.plot(Risk[i,:], Target[i,:], <span class="st">'b-'</span>)</span>
<span id="cb17-10"><a href="#cb17-10"></a>    plt.plot(np.sqrt(np.diagonal(Sigma_hist)), means_hist, <span class="st">'rx'</span>, label<span class="op">=</span><span class="st">'Asset'</span>)</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="cf">for</span> i, txt <span class="kw">in</span> <span class="bu">enumerate</span>(frame1.columns):</span>
<span id="cb17-12"><a href="#cb17-12"></a>        ax.annotate(txt, (np.sqrt(np.diagonal(Sigma_hist))[i],means_hist[i]))</span>
<span id="cb17-13"><a href="#cb17-13"></a>    plt.legend(loc<span class="op">=</span><span class="dv">4</span>,  frameon<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-14"><a href="#cb17-14"></a>    plt.xlabel(<span class="st">'Standard deviation'</span>)</span>
<span id="cb17-15"><a href="#cb17-15"></a>    plt.ylabel(<span class="st">'Expected return'</span>)</span>
<span id="cb17-16"><a href="#cb17-16"></a>    plt.title(<span class="st">'Historical and M simulated efficient frontiers'</span>)</span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="cf">return</span> plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Lassen Sie uns zum Abschluss zehn simulierte und die historische Effizienzkurve graphisch darstellen.</p>
<div id="cell-37" class="cell" data-scrolled="true" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>draw_efs(<span class="dv">10</span>, means_hist, Sigma_hist)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="kapitel6_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="literatur" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="literatur"><span class="header-section-number">7.3</span> Literatur</h2>
<p>Michaud, R.O, Michaud, R.O., (2008). Efficient Asset Management: A Practical Guide to Stock Portfolio Optimization and Asset Allocation, 2nd Edition, Oxford University Press.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./kapitel5.html" class="pagination-link" aria-label="Das Black-Litterman Modell">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Das Black-Litterman Modell</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./kapitel7.html" class="pagination-link" aria-label="Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Risikogesteuerte Ansätze: Verzicht auf die Schätzung der erwarteten Rendite</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>